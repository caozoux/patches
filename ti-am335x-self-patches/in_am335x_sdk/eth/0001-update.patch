From 9eda9b2231a5861a8b76b56acc629118c2e919a7 Mon Sep 17 00:00:00 2001
From: zou cao <cao.zou@windriver.com>
Date: Fri, 29 Sep 2017 10:14:00 +0800
Subject: [PATCH 1/7] update

---
 drivers/net/ethernet/newam335x/Kconfig             |   9 +
 drivers/net/ethernet/newam335x/Makefile            |   5 +
 drivers/net/ethernet/newam335x/ale.h               |  39 ++
 drivers/net/ethernet/newam335x/newam335x_debug.c   |  21 +
 drivers/net/ethernet/newam335x/newam335x_debug.h   |   6 +
 drivers/net/ethernet/newam335x/newam335x_eth_ale.c | 205 +++++++
 .../net/ethernet/newam335x/newam335x_eth_cpdam.c   | 224 +++++++
 .../net/ethernet/newam335x/newam335x_eth_cpdam.h   |  51 ++
 .../net/ethernet/newam335x/newam335x_eth_cpsw.c    | 657 +++++++++++++++++++++
 .../net/ethernet/newam335x/newam335x_eth_cpsw.h    | 193 ++++++
 drivers/net/ethernet/newam335x/newam335x_mdio.c    | 238 ++++++++
 drivers/net/ethernet/newam335x/newam335x_mdio.h    |   0
 12 files changed, 1648 insertions(+)
 create mode 100644 drivers/net/ethernet/newam335x/Kconfig
 create mode 100644 drivers/net/ethernet/newam335x/Makefile
 create mode 100644 drivers/net/ethernet/newam335x/ale.h
 create mode 100644 drivers/net/ethernet/newam335x/newam335x_debug.c
 create mode 100644 drivers/net/ethernet/newam335x/newam335x_debug.h
 create mode 100644 drivers/net/ethernet/newam335x/newam335x_eth_ale.c
 create mode 100644 drivers/net/ethernet/newam335x/newam335x_eth_cpdam.c
 create mode 100644 drivers/net/ethernet/newam335x/newam335x_eth_cpdam.h
 create mode 100644 drivers/net/ethernet/newam335x/newam335x_eth_cpsw.c
 create mode 100644 drivers/net/ethernet/newam335x/newam335x_eth_cpsw.h
 create mode 100644 drivers/net/ethernet/newam335x/newam335x_mdio.c
 create mode 100644 drivers/net/ethernet/newam335x/newam335x_mdio.h

diff --git a/drivers/net/ethernet/newam335x/Kconfig b/drivers/net/ethernet/newam335x/Kconfig
new file mode 100644
index 0000000..67e8054
--- /dev/null
+++ b/drivers/net/ethernet/newam335x/Kconfig
@@ -0,0 +1,9 @@
+
+config NET_VENDOR_NEWAM335X
+	bool "Texas Instruments (TI) devices"
+	default y
+
+config NEWAM335X_ETH_CPSW
+	tristate "NEWAM335X CPSW Switch Support"
+	depends on ARCH_NEWAM335X
+	select PHYLIB
diff --git a/drivers/net/ethernet/newam335x/Makefile b/drivers/net/ethernet/newam335x/Makefile
new file mode 100644
index 0000000..6db0218
--- /dev/null
+++ b/drivers/net/ethernet/newam335x/Makefile
@@ -0,0 +1,5 @@
+ccflags-y := -DDEBUG
+
+obj-$(CONFIG_NEWAM335X_ETH_CPSW) := newam335x_eth_drv.o
+newam335x_eth_drv-y  := newam335x_eth_cpsw.o newam335x_eth_ale.o newam335x_eth_cpdam.o newam335x_mdio.o newam335x_debug.o
+
diff --git a/drivers/net/ethernet/newam335x/ale.h b/drivers/net/ethernet/newam335x/ale.h
new file mode 100644
index 0000000..fa59945
--- /dev/null
+++ b/drivers/net/ethernet/newam335x/ale.h
@@ -0,0 +1,39 @@
+#ifndef __ALE_H__
+#define __ALE_H__
+
+#define ALE_TYPE_FREE			0
+#define ALE_TYPE_ADDR			1
+#define ALE_TYPE_VLAN			2
+#define ALE_TYPE_VLAN_ADDR		3
+
+#define ALE_UCAST_PERSISTANT	0
+#define ALE_UCAST_UNTOUCHED		1
+#define ALE_UCAST_OUI			2
+#define ALE_UCAST_TOUCHED		3
+
+#define ALEBIT_ENTRY_TYPE      (60)
+#define ALEBIT_MCAST_STATE     (62)
+#define ALEBIT_PORT_MASK       (66)
+#define ALEBIT_UCAST_TYPE      (62)
+#define ALEBIT_PORT_NUM        (66)
+#define ALEBIT_BLOCKED 		   (65)
+#define ALEBIT_SECIRE          (64)
+#define ALEBIT_MCAST 		   (40)
+#define ALE_TABLE_WRITE		(1<<31)
+#define ALE_MCAST_FWD_2			3
+
+enum cpsw_ale_port_state {
+	ALE_PORT_STATE_DISABLE	= 0x00,
+	ALE_PORT_STATE_BLOCK	= 0x01,
+	ALE_PORT_STATE_LEARN	= 0x02,
+	ALE_PORT_STATE_FORWARD	= 0x03,
+};
+
+struct newam335x_eth_priv;
+void update_ale_port(struct newam335x_eth_priv *priv, int port, int val);
+int ale_init(struct newam335x_eth_priv *priv, unsigned char *addr);
+int cpsw_ale_add_mcast(struct newam335x_eth_priv *priv, const u8 *addr,int port_mask);
+void ale_dump(struct newam335x_eth_priv *priv);
+			      
+#endif
+
diff --git a/drivers/net/ethernet/newam335x/newam335x_debug.c b/drivers/net/ethernet/newam335x/newam335x_debug.c
new file mode 100644
index 0000000..69c4ade
--- /dev/null
+++ b/drivers/net/ethernet/newam335x/newam335x_debug.c
@@ -0,0 +1,21 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include "newam335x_eth_cpsw.h"
+#include "newam335x_eth_cpdam.h"
+#include <linux/newam335x_debug.h>
+
+
+void dump_skb(struct sk_buff *skb)
+{
+	printk("zz %s sdk->len:%08x \n",__func__, (int)skb->len);
+	printk("zz %s sdk->data_len:%08x \n",__func__, (int)skb->data_len);
+	printk("zz %s skb->mac_len:%08x \n",__func__, (int)skb->mac_len);
+	printk("zz %s skb->pkt_type:%08x \n",__func__, (int)skb->pkt_type);
+}
+
+
diff --git a/drivers/net/ethernet/newam335x/newam335x_debug.h b/drivers/net/ethernet/newam335x/newam335x_debug.h
new file mode 100644
index 0000000..115f68c
--- /dev/null
+++ b/drivers/net/ethernet/newam335x/newam335x_debug.h
@@ -0,0 +1,6 @@
+#ifndef __NEWAM335X_DEBUG_H__
+#define __NEWAM335X_DEBUG_H__
+
+void dump_skb(struct sk_buff *skb);
+
+#endif /* ifndef __NEWAM335X_DEBUG_H__ */
diff --git a/drivers/net/ethernet/newam335x/newam335x_eth_ale.c b/drivers/net/ethernet/newam335x/newam335x_eth_ale.c
new file mode 100644
index 0000000..e3d8c05
--- /dev/null
+++ b/drivers/net/ethernet/newam335x/newam335x_eth_ale.c
@@ -0,0 +1,205 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include "ale.h"
+#include "newam335x_eth_cpsw.h"
+
+#define BITMASK(bits) 	((1<<bits) - 1)
+#define PKT_MAX			(1500 + 14 + 4 + 4)
+
+static int cpsw_ale_read(struct newam335x_eth_priv *priv, int idx, u32 *ale_entry);
+
+void ale_dump(struct newam335x_eth_priv *priv)
+{
+	u32 ale_entry[3];
+	int idx;
+
+	printk("control:%08x \n", readl(priv->ale_regs+CPSW_ALE_CONTROL));
+	printk("port0:%08x \n", readl(priv->ale_regs+CPSW_ALE_PORTCTL0));
+	printk("port1:%08x \n", readl(priv->ale_regs+CPSW_ALE_PORTCTL1));
+	for (idx = 0; idx < 20; idx++) {
+		cpsw_ale_read(priv, idx, ale_entry);
+		printk("zz %s ale_entry[0]:%08x ale_entry[1]:%08x ale_entry[2]:%08x \n",__func__, ale_entry[0], ale_entry[1], ale_entry[2]);
+	}
+
+}
+
+void ale_bit_set(u32 *ale_entry, int off, int bits, u32 val)
+{
+	int idx;
+
+	val &= BITMASK(bits);
+	idx    = off / 32;
+	off -= idx * 32;
+	idx    = 2 - idx; /* flip */
+	ale_entry[idx] &= ~(BITMASK(bits) << off);
+	ale_entry[idx] |=  (val << off);
+}
+
+u8 ale_bit_get(u32 *ale_entry, int off, int bits)
+{
+	int idx;
+
+	idx    = off / 32;
+	off -= idx * 32;
+	idx    = 2 - idx; /* flip */
+	return (ale_entry[idx] >> off ) & BITMASK(bits);
+}
+
+static int cpsw_ale_read(struct newam335x_eth_priv *priv, int idx, u32 *ale_entry)
+{
+	int i;
+	writel(idx, priv->ale_regs+CPSW_ALE_TBLCTL);
+
+	for (i = 0; i < 3; i++)
+		ale_entry[i] = readl(priv->ale_regs + CPSW_ALE_TBLW2 + 4 * i);
+
+	return idx;
+}
+
+static int cpsw_ale_write(struct newam335x_eth_priv *priv, int idx, u32 *ale_entry)
+{
+	int i;
+
+	for (i = 0; i < 3; i++)
+		writel(ale_entry[i], priv->ale_regs+ CPSW_ALE_TBLW2+ 4 * i);
+
+	writel(idx|ALE_TABLE_WRITE, priv->ale_regs + CPSW_ALE_TBLCTL);
+
+	return idx;
+}
+
+static int cpsw_ale_match_addr(struct newam335x_eth_priv *priv, const u8 *addr)
+{
+	u32 ale_entry[3];
+	int type, idx, i;
+
+	for (idx = 0; idx < 1024; idx++) {
+		u8 entry_addr[6];
+
+		cpsw_ale_read(priv, idx, ale_entry);
+		type = ale_bit_get(ale_entry, ALEBIT_ENTRY_TYPE, 2);
+		if (type != ALE_TYPE_ADDR && type != ALE_TYPE_VLAN_ADDR)
+			continue;
+		for (i = 0; i < 6; i++)
+			entry_addr[i] = ale_bit_get(ale_entry, 40 - 8*i, 8);
+
+		if (memcmp(entry_addr, addr, 6) == 0)
+			return idx;
+	}
+	return -ENOENT;
+}
+
+static int cpsw_ale_match_free(struct newam335x_eth_priv *priv)
+{
+	u32 ale_entry[3];
+	int type, idx;
+
+	for (idx = 0; idx < 1024; idx++) {
+		cpsw_ale_read(priv, idx, ale_entry);
+		type = ale_bit_get(ale_entry, ALEBIT_ENTRY_TYPE, 2);
+		if (type == ALE_TYPE_FREE)
+			return idx;
+	}
+	return -ENOENT;
+}
+
+static int cpsw_ale_find_ageable(struct newam335x_eth_priv *priv)
+{
+	u32 ale_entry[3];
+	int type, idx;
+
+	for (idx = 0; idx < 1024; idx++) {
+		cpsw_ale_read(priv, idx, ale_entry);
+		type = ale_bit_get(ale_entry, ALEBIT_ENTRY_TYPE, 2);
+		if (type != ALE_TYPE_ADDR && type != ALE_TYPE_VLAN_ADDR)
+			continue;
+		if (ale_bit_get(ale_entry, ALEBIT_MCAST, 1))
+			continue;
+
+		type = ale_bit_get(ale_entry, ALEBIT_UCAST_TYPE, 2);
+		if (type != ALE_UCAST_PERSISTANT &&
+		    type != ALE_UCAST_OUI)
+			return idx;
+	}
+	return -ENOENT;
+}
+
+int cpsw_ale_add_mcast(struct newam335x_eth_priv *priv, const u8 *addr,
+			      int port_mask)
+{
+	u32 ale_entry[3] = {0, 0, 0};
+	int idx, mask, i;
+
+	idx = cpsw_ale_match_addr(priv, addr);
+	if (idx >= 0)
+		cpsw_ale_read(priv, idx, ale_entry);
+
+	ale_bit_set(ale_entry, ALEBIT_ENTRY_TYPE, 2, ALE_TYPE_ADDR);
+	for (i = 0; i < 6; i++)
+		ale_bit_set(ale_entry, 40 - 8*i, 8, addr[i]);
+	ale_bit_set(ale_entry, ALEBIT_MCAST_STATE, 2, ALE_MCAST_FWD_2);
+
+	mask = ale_bit_get(ale_entry, ALEBIT_PORT_MASK, 3);
+	port_mask |= mask;
+	ale_bit_set(ale_entry, ALEBIT_PORT_MASK, 3, port_mask);
+
+	if (idx < 0)
+		idx = cpsw_ale_match_free(priv);
+	if (idx < 0)
+		idx = cpsw_ale_find_ageable(priv);
+	if (idx < 0) {
+		printk("failed set mac addr\n");
+		return -ENOMEM;
+	}
+
+	cpsw_ale_write(priv, idx, ale_entry);
+
+	return 0;
+}
+int ale_init(struct newam335x_eth_priv *priv, u8 *addr)
+{
+	const u8 net_bcast_ethaddr[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
+	u32 ale_entry[3] = {0, 0, 0};
+	int i;
+	int idx;
+
+	ale_bit_set(ale_entry, ALEBIT_ENTRY_TYPE, 2, ALE_TYPE_ADDR);
+
+	for (i = 0; i < 6; i++)
+		ale_bit_set(ale_entry, 40 - 8*i, 8, addr[i]);
+
+	ale_bit_set(ale_entry, ALEBIT_UCAST_TYPE, 2 , ALE_UCAST_PERSISTANT);
+	ale_bit_set(ale_entry, ALEBIT_SECIRE, 1, 1);
+	ale_bit_set(ale_entry, ALEBIT_BLOCKED, 1, 0);
+	ale_bit_set(ale_entry, ALEBIT_PORT_NUM, 2, 0);
+
+	idx = cpsw_ale_match_addr(priv, addr);
+	if (idx < 0)
+		idx = cpsw_ale_match_free(priv);
+	if (idx < 0)
+		idx = cpsw_ale_find_ageable(priv);
+	if (idx < 0) {
+		printk("zz %s %d err\n", __func__, __LINE__);
+		return -ENOMEM;
+	}
+
+	//add the ucase addr
+	cpsw_ale_write(priv, idx, ale_entry);
+	
+	cpsw_ale_add_mcast(priv, net_bcast_ethaddr, 1<<1);
+
+	return 0;
+}
+
+void update_ale_port(struct newam335x_eth_priv *priv, int port, int val)
+{
+	int offset = CPSW_ALE_PORTCTL0 + 4 * port;
+	u32 tmp, mask = 0x3;
+
+	tmp  = __raw_readl(priv->ale_regs + offset);
+	tmp &= ~mask;
+	tmp |= val & mask;
+	__raw_writel(tmp, priv->ale_regs + offset);
+}
diff --git a/drivers/net/ethernet/newam335x/newam335x_eth_cpdam.c b/drivers/net/ethernet/newam335x/newam335x_eth_cpdam.c
new file mode 100644
index 0000000..f26eda9
--- /dev/null
+++ b/drivers/net/ethernet/newam335x/newam335x_eth_cpdam.c
@@ -0,0 +1,224 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include "newam335x_eth_cpsw.h"
+#include "newam335x_eth_cpdam.h"
+#include <linux/newam335x_debug.h>
+
+void loop_dealy(int ms)
+{
+	volatile u32 i, j, k;
+	for (i = 0; i < ms; i++) {
+		for (j = 0; j < 100; j++) {
+			for (k = 0; k < 3000; k++) {
+			}
+		}
+	}
+}
+
+void newam335x_cpdma_dump(struct newam335x_eth_priv *priv, struct cpdma_desc *desc)
+{
+	printk("zz %s desc:%08x \n",__func__, (int)desc);
+	printk("hw_next:%08x \n",desc_read(desc, hw_next));
+	printk("hw_buffer:%08x \n",desc_read(desc, hw_buffer));
+	printk("hw_len:%08x \n",desc_read(desc, hw_len));
+	printk("hw_mode:%08x \n",desc_read(desc, hw_mode));
+	printk("sw_buffer:%08x \n",desc_read(desc, sw_buffer));
+	printk("sw_len:%08x \n",desc_read(desc, sw_len));
+	printk("dma_status:%08x \n",__raw_readl(priv->dma_regs+0x24));
+	printk("dma_tx_pend:%08x \n",__raw_readl(priv->dma_regs+0x80));
+	printk("wr_rx_status:%08x \n",__raw_readl((void*)priv->wr_regs+0x44));
+	printk("wr_tx_status:%08x \n",__raw_readl((void*)priv->wr_regs+0x48));
+	newam335x_interrupt_debug(58);
+}
+
+void newam335x_cpdma_rx_state(struct newam335x_eth_priv *priv)
+{
+	struct cpdma_desc *desc;
+	struct cpdma_chan *chan;
+	struct transfer_data * desc_data, *desc_data_head;
+	u32 status, len;
+
+	chan = &priv->rx_chan;
+
+	desc_data = list_first_entry(&chan->list, struct transfer_data, head);
+	desc = desc_data->desc;
+		
+	while(1) {
+		desc_data = list_first_entry(&chan->list, struct transfer_data, head);
+		desc = desc_data->desc;
+		
+		loop_dealy(5000);
+		list_for_each_entry(desc_data, &chan->list, head) {
+			newam335x_cpdma_dump(priv, desc_data->desc);
+		}
+	}
+}
+
+struct transfer_data * cpdma_alloc(struct newam335x_eth_priv *priv)
+{
+	struct transfer_data  *desc_data;
+
+	if (list_empty(&priv->free_list))
+		return NULL;
+
+	desc_data = list_first_entry(&priv->free_list, struct transfer_data, head);
+	if (desc_data) {
+		//list_del(&desc_data->head);
+		list_del_init(&desc_data->head);
+		return desc_data;
+	}
+
+	return NULL;
+}
+
+void cpdma_free(struct newam335x_eth_priv *priv, struct transfer_data *desc_data)
+{
+	if (desc_data)
+		list_add_tail(&desc_data->head, &priv->free_list);
+}
+
+int cpdma_eoi_write(struct newam335x_eth_priv *priv, int val)
+{
+	__raw_writel(val, priv->dma_regs+ CPDMA_EIO_VECT);
+}
+
+int cpdma_submit(struct newam335x_eth_priv *priv, struct sk_buff *skb, bool isTx)
+{
+	struct cpdma_desc *desc, *prev;
+	struct transfer_data *desc_data, *prev_data;
+	struct cpdma_chan *chan;
+	dma_addr_t dma_addr;
+	u32 mode, start, ret, len;
+
+	desc_data = cpdma_alloc(priv);
+	if (!desc_data) {
+		printk("Error: no desc to alloc\n");
+		return -ENOMEM;
+	}
+
+	if (isTx) {
+		chan = &priv->tx_chan;
+		dma_addr = dma_map_single(&priv->pdev->dev, skb->data, skb->len, DMA_TO_DEVICE);
+	} else {
+		dma_addr = dma_map_single(&priv->pdev->dev, skb->data, skb->len, DMA_FROM_DEVICE);
+		chan = &priv->rx_chan;
+	}
+
+	ret = dma_mapping_error(&priv->pdev->dev, dma_addr);
+	if (ret)
+		dev_err(&priv->pdev->dev, "dma map failed\n");
+
+	len=skb->len;
+	desc_data->skb = skb;
+	desc = desc_data->desc;
+	//printk("zz %s desc:%08x \n",__func__, DESC_PHYADDR(priv, desc));
+
+	mode = CPDMA_DESC_OWNER | CPDMA_DESC_SOP | CPDMA_DESC_EOP;
+	desc_write(desc, hw_next,   0);
+	desc_write(desc, hw_buffer, dma_addr);
+	desc_write(desc, hw_len,    len);
+	desc_write(desc, hw_mode,   mode | len);
+	desc_write(desc, sw_buffer, desc_data);
+	desc_write(desc, sw_len,    len);
+
+	if (len < PKT_MIN)
+		len = PKT_MIN;
+
+	if (list_empty(&chan->list)) {
+		/* simple case - first packet enqueued */
+		list_add_tail(&desc_data->head, &chan->list);
+		chan_write(chan, hdp, DESC_PHYADDR(priv, desc));
+
+		goto done;
+	}
+	
+	/* not the first packet - enqueue at the tail */
+	prev_data = list_last_entry(&chan->list, struct transfer_data, head);
+	prev = prev_data->desc;
+	desc_write(prev, hw_next, DESC_PHYADDR(priv, desc));
+	list_add_tail(&desc_data->head, &chan->list);
+
+	/* next check if EOQ has been triggered already */
+	if (desc_read(prev, hw_mode) & CPDMA_DESC_EOQ)
+		chan_write(chan, hdp, DESC_PHYADDR(priv, desc));
+
+done:
+
+#if 0
+	if(isTx) {
+		while(1) {
+			loop_dealy(1000);
+			newam335x_cpdma_dump(priv, desc);
+		}
+	}
+#endif
+	if (chan->rxfree)
+		chan_write(chan, rxfree, 1);
+
+	return 0;
+}
+
+void cpdma_enable(struct newam335x_eth_priv *priv, bool enable)
+{
+	if (enable) {
+		__raw_writel(1, priv->dma_regs + CPDMA_TXCONTROL);
+		__raw_writel(1, priv->dma_regs + CPDMA_RXCONTROL);
+	} else {
+		__raw_writel(0, priv->dma_regs + CPDMA_TXCONTROL);
+		__raw_writel(0, priv->dma_regs + CPDMA_RXCONTROL);
+	}
+	//newam335x_cpdma_rx_state(priv);
+}
+
+void newam335x_cpdam_init(struct newam335x_eth_priv *priv)
+{
+	u32 val;
+	long start;
+	int i, ret;
+
+	INIT_LIST_HEAD(&priv->tx_chan);
+	priv->tx_chan.hdp       = priv->dma_regs + CPDMA_TXHDP_VER2;
+	priv->tx_chan.cp        = priv->dma_regs + CPDMA_TXCP_VER2;
+
+	INIT_LIST_HEAD(&priv->rx_chan);
+	priv->rx_chan.hdp       = priv->dma_regs + CPDMA_RXHDP_VER2;
+	priv->rx_chan.cp        = priv->dma_regs + CPDMA_RXCP_VER2;
+	priv->rx_chan.rxfree    = priv->dma_regs + CPDMA_RXFREE;
+
+	__raw_writel(0, priv->dma_regs + CPDMA_TXCONTROL);
+	__raw_writel(0, priv->dma_regs + CPDMA_RXCONTROL);
+
+	/* clear dma state */
+	__raw_writel(1, priv->dma_regs + CPDMA_SOFTRESET);
+	start = jiffies + 10*HZ;
+	do  {
+		if (time_after(jiffies, start)) {
+			printk("Error: reset cpdma failed");
+			return;
+		}
+		val = __raw_readl(priv->dma_regs + CPDMA_SOFTRESET);
+		msleep(1);
+	} while((val&1) == 1);
+
+	for (i = 0; i < CPDMA_DESC_NUM; i++) {
+		desc_write(&priv->desc[i], hw_next,
+			   (i == (CPDMA_DESC_NUM - 1)) ? 0 : &priv->desc[i+1]);
+	}
+
+	for (i = 0; i < 8; i++) {
+		__raw_writel(0, priv->dma_regs + CPDMA_RXHDP_VER2 + 4*i);
+		__raw_writel(0, priv->dma_regs + CPDMA_RXFREE + 4*i);
+		__raw_writel(0, priv->dma_regs + CPDMA_RXCP_VER2 + 4*i);
+		__raw_writel(0, priv->dma_regs + CPDMA_TXHDP_VER2 + 4*i);
+		__raw_writel(0, priv->dma_regs + CPDMA_TXCP_VER2 + 4*i);
+	}
+
+	__raw_writel(0xff, priv->dma_regs + CPDMA_TX_CLR_MASK);
+	__raw_writel(0xff, priv->dma_regs + CPDMA_RX_CLR_MASK);
+}
+
diff --git a/drivers/net/ethernet/newam335x/newam335x_eth_cpdam.h b/drivers/net/ethernet/newam335x/newam335x_eth_cpdam.h
new file mode 100644
index 0000000..fe41483
--- /dev/null
+++ b/drivers/net/ethernet/newam335x/newam335x_eth_cpdam.h
@@ -0,0 +1,51 @@
+#ifndef __NEWMA335X_ETH_CPDMA_H__
+#define __NEWMA335X_ETH_CPDMA_H__
+
+#define CPDMA_TXHDP_VER2	0x200
+#define CPDMA_TXCP_VER2		0x240
+#define CPDMA_RXHDP_VER2	0x220
+#define CPDMA_RXCP_VER2		0x260
+#define CPDMA_RXFREE		0x0e0
+
+/* DMA Registers */
+#define CPDMA_TXCONTROL		0x004
+#define CPDMA_RXCONTROL		0x014
+#define CPDMA_SOFTRESET		0x01c
+#define CPDMA_RXFREE		0x0e0
+#define CPDMA_TX_CLR_MASK   0x88
+#define CPDMA_TX_SET_MASK   0x8c
+#define CPDMA_RX_CLR_MASK   0xa8
+#define CPDMA_RX_SET_MASK   0xac
+#define CPDMA_IN_VECT 	    0x90
+#define CPDMA_EIO_VECT 	    0x94
+
+/* Descriptor mode bits */
+#define CPDMA_DESC_SOP		(1<<31)
+#define CPDMA_DESC_EOP		(1<<30)
+#define CPDMA_DESC_OWNER	(1<<29)
+#define CPDMA_DESC_EOQ		(1<<28)
+
+#define PKTBUFSRX 8
+#define PKT_MIN			60
+#define CPDMA_DESC_NUM (PKTBUFSRX*2)
+#define PKTSIZE 	(4096)
+
+#define desc_write(desc, fld, val)	__raw_writel((u32)(val), &(desc)->fld)
+#define desc_read(desc, fld)		__raw_readl(&(desc)->fld)
+#define desc_read_ptr(desc, fld)	((void *)__raw_readl(&(desc)->fld))
+
+#define chan_write(chan, fld, val)	__raw_writel((u32)(val), (chan)->fld)
+#define chan_read(chan, fld)		__raw_readl((chan)->fld)
+#define chan_read_ptr(chan, fld)	((void *)__raw_readl((chan)->fld))
+
+#define DESC_PHYADDR(priv, DESC) (((void*)DESC-(void*)&priv->desc[0])+CPPI_RAM_BASE)
+
+void newam335x_cpdam_init(struct newam335x_eth_priv *priv);
+int cpdma_submit(struct newam335x_eth_priv *priv, struct sk_buff *skb, bool isTx);
+void cpdma_enable(struct newam335x_eth_priv *priv, bool enable);
+int cpdma_eoi_write(struct newam335x_eth_priv *priv, int val);
+int handle_cpdma_desc(struct newam335x_eth_priv *priv, bool isTx);
+void cpdma_free(struct newam335x_eth_priv *priv, struct transfer_data *desc_data);
+void newam335x_cpdma_dump(struct newam335x_eth_priv *priv, struct cpdma_desc *desc);
+#endif /* ifndef __NEWMA335X_ETH_CPDMA_H__ */
+
diff --git a/drivers/net/ethernet/newam335x/newam335x_eth_cpsw.c b/drivers/net/ethernet/newam335x/newam335x_eth_cpsw.c
new file mode 100644
index 0000000..ce53e5a
--- /dev/null
+++ b/drivers/net/ethernet/newam335x/newam335x_eth_cpsw.c
@@ -0,0 +1,657 @@
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/irqreturn.h>
+#include <linux/interrupt.h>
+#include <linux/if_ether.h>
+#include <linux/etherdevice.h>
+#include <linux/netdevice.h>
+#include <linux/net_tstamp.h>
+#include <linux/skbuff.h>
+#include <linux/phy.h>
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+#include <linux/pm_runtime.h>
+#include <linux/of.h>
+#include <linux/of_net.h>
+#include <linux/of_device.h>
+#include <linux/if_vlan.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/netdevice.h>
+#include <net/busy_poll.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/if_ether.h>
+#include <linux/delay.h>
+#include <linux/list.h>
+#include "newam335x_eth_cpsw.h"
+#include "newam335x_eth_cpdam.h"
+#include "newam335x_debug.h"
+#include "ale.h"
+
+#define CPSW_MAX_PACKET_SIZE	(1500 + 14 + 4 + 4)
+#define POLL_WEIGHT (64)
+#define NEWAM335X_CPSW_MAX_QUEUES 8
+#define PKT_MAX			(1500 + 14 + 4 + 4)
+#define mac_hi(mac) (((mac)[0] << 0) | ((mac)[1] << 8) |    \
+	   ((mac)[2] << 16) | ((mac)[3] << 24))
+#define mac_lo(mac) (((mac)[4] << 0) | ((mac)[5] << 8))
+
+int queue_rx_packages(struct newam335x_eth_priv *priv);
+static int handle_rx_package(struct newam335x_eth_priv *priv);
+
+int gen_get_settings(struct net_device *netdev, struct ethtool_cmd *cmd)
+{   
+	printk("zz %s %d \n", __func__, __LINE__);
+  return 0;
+}   
+
+int gen_set_settings(struct net_device *netdev, struct ethtool_cmd *cmd)
+{   
+	printk("zz %s %d \n", __func__, __LINE__);
+  return 0;
+}   
+
+int gen_get_coalesce(struct net_device *netdev, struct ethtool_coalesce *cmd)
+{   
+	printk("zz %s %d \n", __func__, __LINE__);
+  return 0;
+}   
+  
+int gen_set_coalesce(struct net_device *netdev, struct ethtool_coalesce *cls)
+{
+	printk("zz %s %d \n", __func__, __LINE__);
+  return 0;
+}
+
+void gen_get_drvinfo(struct net_device *netdev, struct ethtool_drvinfo *info)
+{   
+	printk("zz %s %d \n", __func__, __LINE__);
+}   
+
+void gen_get_ringparam(struct net_device *netdev,
+		   struct ethtool_ringparam *pra) 
+{
+	printk("zz %s %d \n", __func__, __LINE__);
+}
+  
+int gen_set_ringparam(struct net_device *netdev,
+		   struct ethtool_ringparam *pra)
+{
+	printk("zz %s %d \n", __func__, __LINE__);
+  return 0;
+}
+
+const struct ethtool_ops newam335x_netdev_tool = {
+  .get_link       = ethtool_op_get_link,
+  .get_settings   = gen_get_settings,
+  .set_settings   = gen_set_settings,
+  .set_coalesce   = gen_set_coalesce,
+  .get_coalesce   = gen_get_coalesce,
+  .get_drvinfo    = gen_get_drvinfo,
+  .get_ringparam  = gen_get_ringparam,
+  .set_ringparam  = gen_set_ringparam,
+};
+
+#define MAX_TIMEOUT 
+/* Set a self-clearing bit in a register, and wait for it to clear */
+static int setbit_and_wait_for_clear32(void *addr)
+{
+	long timeout = jiffies + 4*HZ;
+
+	__raw_writel(1, addr);
+	while (__raw_readl(addr) & 1) {
+		if (time_after(jiffies, timeout)) {
+			return 1;
+		}
+		msleep(1);
+	}
+	return 0;
+}
+
+static void newam335x_slave_init(struct newam335x_eth_priv *priv, int port)
+{
+	const u8 net_bcast_ethaddr[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
+	struct cpsw_sl_regs *slave;
+	struct cpsw_port1_regs *port_reg;
+	int offset = CPSW_ALE_PORTCTL0+ 4 * port;
+	u32 val;
+	u32 tmp, mask = 0x3;
+
+	if (port == 0) {
+		slave = priv->sl1_regs;
+		port_reg = (struct cpsw_port1_regs *)priv->port1_regs;
+	} else if (port == 1) {
+		slave = priv->sl2_regs;
+		port_reg = priv->port2_regs;
+	}
+	
+	setbit_and_wait_for_clear32(&slave->soft_reset);
+
+	/* setup priority mapping */
+	__raw_writel(0x76543210, &slave->rx_pri_map);
+	__raw_writel(0x33221100, &port_reg->tx_pri_map);
+
+	/* setup max packet size, and mac address */
+	__raw_writel(PKT_MAX, &slave->rx_maxlen);
+	__raw_writel(mac_hi(priv->defaut_mac), &port_reg->sa_hi);
+	__raw_writel(mac_lo(priv->defaut_mac), &port_reg->sa_lo);
+
+	/* enable forwarding */
+	update_ale_port (priv, port+1, ALE_PORT_STATE_FORWARD);
+
+	cpsw_ale_add_mcast(priv, net_bcast_ethaddr, 1);
+
+
+	__raw_writel(1|1<<15|1<<5, &slave->mac_control);
+}
+
+/*
+ * cpsw_rw control the cpsw mac interrupt, here init it.
+ */
+static void newam335x_interrupt_init(struct newam335x_eth_priv *priv)
+{
+#define WR_CONTORL_PLUS_EN(val)  (val<<16)
+	struct cpsw_wr_regs *wr_regs = priv->wr_regs;
+	u32 val;
+
+	//setbit_and_wait_for_clear32(&wr_regs->soft_reset);
+
+	/*enable dma chanle 0 interrupt*/
+	__raw_writel(0x1, &wr_regs->rx_en);
+	__raw_writel(0x1, &wr_regs->tx_en);
+
+}
+
+static int newam335x_eth_init(struct net_device *ndev)
+{
+	u32 start;
+	u32 val;
+	struct newam335x_eth_priv *priv = (struct newam335x_eth_priv *) netdev_priv(ndev);
+
+	setbit_and_wait_for_clear32(&priv->ss_regs->soft_reset);
+
+	//writel(readl(&priv->ale_regs+CPSW_ALE_CONTROL) & ~(1<<2),
+	//		priv->ale_regs+CPSW_ALE_CONTROL);  /* vlan unaware mode */
+	val = readl(priv->ale_regs+CPSW_ALE_CONTROL);
+	val |= 1<<31;
+	writel(val, priv->ale_regs+CPSW_ALE_CONTROL);
+	val |= 1<<30;
+	writel(val, priv->ale_regs+CPSW_ALE_CONTROL);
+
+	/* setup host port priority mapping */
+	__raw_writel(0x76543210, &priv->port0_regs->cpdma_tx_pri_map);
+	__raw_writel(0, &priv->port0_regs->cpdma_rx_chan_map);
+
+	/* disable priority elevation and enable statistics on all ports */
+	__raw_writel(0, &priv->ss_regs->ptype);
+
+	/* enable statistics collection only on the host port */
+	__raw_writel(1, &priv->ss_regs->stat_port_en);
+	__raw_writel(0x7, &priv->ss_regs->stat_port_en);
+
+	update_ale_port(priv, 0, ALE_PORT_STATE_FORWARD);
+
+	ale_init(priv, priv->defaut_mac);
+
+	newam335x_slave_init(priv, 0);
+
+	newam335x_cpdam_init(priv);
+
+	newam335x_interrupt_init(priv);
+
+	queue_rx_packages(priv);
+#if 0
+	newam335x_phy_init(dev);
+	phy_startup(priv->phydev);
+#endif
+
+	return 0;
+}
+
+
+static void eth_adjust_link(struct net_device *ndev)
+{
+	struct newam335x_eth_priv *priv = (struct newam335x_eth_priv *) netdev_priv(ndev);
+	struct phy_device *phydev = priv->phydev;
+
+	printk("zz %s %d link:%d\n", __func__, __LINE__, phydev->link);
+
+	if (phydev->link) {
+		netif_carrier_on(ndev);
+		cpdma_enable(priv, true);
+	} else {
+		//cpdma_enable(priv, false);
+	}
+}
+
+static int cpsw_ndo_open(struct net_device *ndev)
+{
+	struct newam335x_eth_priv *priv = (struct newam335x_eth_priv *) netdev_priv(ndev);
+	struct phy_device *phydev;
+	char phy_id[MII_BUS_ID_SIZE + 3];
+
+	printk("zz %s %d \n", __func__, __LINE__);
+
+	newam335x_eth_init(ndev);
+
+	snprintf(phy_id, sizeof(phy_id), PHY_ID_FMT,
+		 "newam335x_mdio", 0);
+	phydev = phy_connect(ndev, phy_id, eth_adjust_link,
+	 			PHY_INTERFACE_MODE_MII);
+
+	if (IS_ERR(phydev)) {
+		netdev_err(ndev, "Can not get phy\n");
+		return 1;
+	}
+
+	netif_carrier_off(ndev);
+	ndev->phydev = phydev;
+	priv->phydev = phydev;
+	phy_start(ndev->phydev);
+
+	return 0;
+}
+
+static int cpsw_ndo_stop(struct net_device *ndev)
+{
+	printk("zz %s %d \n", __func__, __LINE__);
+	return 0;
+}
+
+static int cpsw_ndo_start_xmit (struct sk_buff *skb,
+                           struct net_device *ndev)
+{
+	struct newam335x_eth_priv *priv;
+	priv = netdev_priv(ndev);
+
+	skb_tx_timestamp(skb);
+	printk("zz %s %d \n", __func__, __LINE__);
+	cpdma_submit(priv, skb, 1);
+    return NETDEV_TX_OK;
+}
+
+static int generic_ndo_set_mac_address(struct net_device *ndev,
+                               void *addr)
+{
+	printk("zz %s %d \n", __func__, __LINE__);
+    return 0;
+}
+  
+static int cpsw_ndo_ioctl(struct net_device *dev,
+                            struct ifreq *ifr, int cmd)
+{
+	printk("zz %s %d \n", __func__, __LINE__);
+    return 0;
+}
+
+static void cpsw_ndo_tx_timeout(struct net_device *ndev)
+{
+	printk("zz %s %d \n", __func__, __LINE__);
+}
+  
+static void cpsw_ndo_set_rx_mode(struct net_device *ndev)
+{
+	printk("zz %s %d \n", __func__, __LINE__);
+}
+  
+static int cpsw_ndo_vlan_rx_add_vid(struct net_device *ndev,
+                               __be16 proto, u16 vid)
+{
+	printk("zz %s %d \n", __func__, __LINE__);
+      return 0;
+}
+  
+static int cpsw_ndo_vlan_rx_kill_vid(struct net_device *ndev,
+                       __be16 proto, u16 vid)
+{
+	printk("zz %s %d \n", __func__, __LINE__);
+     return 0;
+}
+
+static const struct net_device_ops newam335x_netdev_ops = {
+	.ndo_open       = cpsw_ndo_open,
+	.ndo_stop       = cpsw_ndo_stop,
+	.ndo_start_xmit     = cpsw_ndo_start_xmit,
+	.ndo_set_mac_address    = generic_ndo_set_mac_address,
+	.ndo_do_ioctl       = cpsw_ndo_ioctl,
+	.ndo_validate_addr  = eth_validate_addr,
+	//.ndo_change_mtu       = eth_change_mtu,
+	.ndo_tx_timeout     = cpsw_ndo_tx_timeout,
+	.ndo_set_rx_mode    = cpsw_ndo_set_rx_mode,
+	.ndo_vlan_rx_add_vid    = cpsw_ndo_vlan_rx_add_vid,
+	.ndo_vlan_rx_kill_vid   = cpsw_ndo_vlan_rx_kill_vid,
+};
+
+int queue_rx_packages(struct newam335x_eth_priv *priv)
+{
+	struct sk_buff *skb;
+	int ch, ret;
+
+	for (ch = 0; ch < RX_PACKAGE_NUM; ch++) {
+		skb = __netdev_alloc_skb_ip_align(priv->ndev,
+						  CPSW_MAX_PACKET_SIZE,
+						  GFP_KERNEL);
+		if (!skb) {
+			dev_err(&priv->pdev->dev,  "cannot allocate skb\n");
+			return -ENOMEM;
+		}
+
+		skb->len = CPSW_MAX_PACKET_SIZE;
+		ret = cpdma_submit(priv, skb, 0);
+
+		if (ret) {
+			dev_kfree_skb_any(skb);
+			dev_err(&priv->pdev->dev, "submit package error\n");
+			return -ENOENT;
+		}
+	}
+
+	return 0;
+}
+
+static int eth_rx_poll(struct napi_struct *napi_rx, int budget)
+{
+	struct newam335x_eth_priv *priv;
+	//printk("zz %s %d \n", __func__, __LINE__);
+	priv = netdev_priv(napi_rx->dev);
+	handle_rx_package(priv);
+	enable_irq(priv->rx_irq);
+	//printk("zz %s %d \n", __func__, __LINE__);
+	return 0;
+}
+
+static int eth_tx_poll(struct napi_struct *napi_tx, int budget)
+{
+	return 0;
+}
+
+static int handle_tx_package(struct newam335x_eth_priv *priv)
+{
+	struct cpdma_chan *chan;
+	struct cpdma_desc *desc;
+	struct transfer_data *desc_data;
+	struct sk_buff *skb;
+	struct net_device *ndev;
+	u32 len, status;
+
+	ndev = priv->ndev;
+	chan = &priv->tx_chan;
+	desc_data = list_first_entry(&chan->list, struct transfer_data, head);
+
+	if (!desc_data || !desc_data->desc)
+		return -ENOMEM;
+
+	do {
+		desc = desc_data->desc;
+		status = desc_read(desc, hw_mode);
+		if (status & CPDMA_DESC_OWNER) {
+			return -ENXIO;
+		} else {
+			desc_data = (struct transfer_data*)desc->sw_buffer;
+			skb = (struct sk_buff *) desc_data->skb;
+			len = status & 0x7ff;
+
+			ndev->stats.tx_packets++;
+			ndev->stats.tx_bytes += len;
+			dev_kfree_skb_any(skb);
+			desc_data->skb = NULL;
+			list_del(&desc_data->head);
+
+			/*last desc*/
+			if (status & CPDMA_DESC_EOQ) {
+				//printk("zz %s desc_data->head->prev:%08x desc_data->head->next:%08x \n",__func__, (int)desc_data->head.prev, (int)desc_data->head.next);
+				cpdma_free(priv, desc_data);
+				chan_write(chan, cp, DESC_PHYADDR(priv, desc_data->desc));
+				cpdma_eoi_write(priv, 2);
+
+				if (!list_empty(&chan->list)) {
+					dev_dbg(&priv->pdev->dev, "zz %s %d isn't empty\n", __func__, __LINE__);
+					desc_data = list_first_entry(&chan->list, struct transfer_data, head);
+					chan_write(chan, hdp, DESC_PHYADDR(priv, desc_data->desc));
+				}
+				return 0;
+			}
+			cpdma_free(priv, desc_data);
+		}
+		desc_data = list_first_entry(&desc_data->head, struct transfer_data, head);
+	} while(desc_data);
+	return 0;
+}
+
+static irqreturn_t tx_intr(int __always_unused irq, void *data)
+{
+	struct newam335x_eth_priv *priv= data;
+
+	printk("zz %s %d +\n", __func__, __LINE__);
+	handle_tx_package(priv);
+	printk("zz %s %d -\n", __func__, __LINE__);
+	return IRQ_HANDLED;
+}
+
+static int handle_rx_package(struct newam335x_eth_priv *priv)
+{
+	struct cpdma_chan *chan;
+	struct cpdma_desc *desc;
+	struct transfer_data *desc_data;
+	struct sk_buff *skb;
+	struct net_device *ndev;
+	u32 len, status;
+
+	ndev = priv->ndev;
+	chan = &priv->rx_chan;
+
+	while (!list_empty(&chan->list)) {
+
+		desc_data = list_first_entry(&chan->list, struct transfer_data, head);
+		desc = desc_data->desc;
+
+		status = desc_read(desc, hw_mode);
+		if (status & CPDMA_DESC_OWNER) {
+			return -ENXIO;
+		} else {
+			skb = (struct sk_buff *) desc_data->skb;
+			len = status & 0x7ff;
+
+			dump_skb(skb);
+
+			skb_put(skb, len);
+			skb->protocol = eth_type_trans(skb, ndev);
+			netif_receive_skb(skb);
+			ndev->stats.rx_bytes += len;
+			ndev->stats.rx_packets++;
+
+			chan_write(chan, cp, DESC_PHYADDR(priv, desc_data->desc));
+			cpdma_eoi_write(priv, 1);
+
+			list_del(&desc_data->head);
+			cpdma_free(priv, desc_data);
+
+			/*last desc*/
+			if (status & CPDMA_DESC_EOQ) {
+
+				if (!list_empty(&chan->list)) {
+					dev_dbg(&priv->pdev->dev, "list isn't empty, continue write\n");
+					desc_data = list_first_entry(&chan->list, struct transfer_data, head);
+					chan_write(chan, hdp, DESC_PHYADDR(priv, desc_data->desc));
+				} else {
+					queue_rx_packages(priv);
+				}
+
+				return 0;
+			}
+		}
+	};
+
+	return 0;
+}
+
+static irqreturn_t rx_intr(int __always_unused irq, void *data)
+{
+	struct newam335x_eth_priv *priv= data;
+	//__napi_schedule(&priv->napi_rx); it is halt in irq context
+	//__napi_schedule_irqoff(&priv->napi_rx);
+	//disable_irq_nosync(irq);
+	handle_rx_package(priv);
+	return IRQ_HANDLED;
+}
+
+static int newam335x_eth_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct newam335x_eth_priv *priv;
+	struct net_device *ndev;
+	int i, ret, irq, k=0;
+	void __iomem *base;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "resource not find");
+		goto error;
+	}
+
+	//ndev = alloc_etherdev_mq(sizeof(struct newam335x_eth_priv), NEWAM335X_CPSW_MAX_QUEUES);
+	ndev = alloc_etherdev(sizeof(struct newam335x_eth_priv));
+	priv = netdev_priv(ndev);
+	//priv->dev  = &ndev->dev;
+
+	platform_set_drvdata(pdev, ndev);
+
+	memset(priv, 0, sizeof(struct newam335x_eth_priv));
+
+	base = ioremap(res->start, res->end - res->start);
+	if (!base) {
+		kfree(priv);
+		return -EINVAL;
+	}
+
+	printk("zz %s base:%08x \n",__func__, base);
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "resource not find");
+		iounmap(base);
+		goto error;
+	}
+
+	for (i = 0; i < res->end-res->start; ++i) {
+		irq = res->start+i;	
+		printk("zz %s irq:%08x \n",__func__, (int)irq);
+		if (k==2) {
+
+			ret = request_irq(irq, tx_intr, 0,
+				  	pdev->name, priv);
+			priv->tx_irq = irq;
+		} else if (k == 1) {
+			ret = request_irq(irq, rx_intr, 0,
+				  	pdev->name, priv);
+			priv->rx_irq = irq;
+		}
+
+		if (ret)
+			printk("zz %s %d irq err\n", __func__, __LINE__);
+
+		k++;
+	}
+
+#define CPSW_SL1_OFFSET 		0xd80
+#define CPSW_SL2_OFFSET 		0xdc0
+#define CPSW_PORT_OFFSET  		0x100
+#define CPSW_ALE_OFFSET   		0xd00
+#define CPSW_CPDMA_OFFSET 		0x800
+#define CPSW_WR_OFFSET 			0x1200
+	priv->pdev = pdev;
+	priv->ss_regs = base;
+	priv->sl1_regs = (struct cpsw_sl_regs *) (base+CPSW_SL1_OFFSET);
+	priv->sl2_regs = (struct cpsw_sl_regs *) (base+CPSW_SL2_OFFSET);
+	priv->wr_regs =(struct cpsw_wr_regs *) (base+CPSW_WR_OFFSET);
+	priv->port0_regs =(struct cpsw_port0_regs *) (base+CPSW_PORT_OFFSET+0x08);
+	priv->port1_regs =(struct cpsw_port1_regs *) (base+CPSW_PORT_OFFSET+0x108);
+	priv->port2_regs =(struct cpsw_port1_regs *) (base+CPSW_PORT_OFFSET+0x208);
+	priv->ale_regs = (void*) base+CPSW_ALE_OFFSET;
+	priv->dma_regs = (void*) base+CPSW_CPDMA_OFFSET;
+
+	INIT_LIST_HEAD(&priv->free_list);
+	priv->desc		= (struct cpdma_desc*) (base+CPPI_RAM_OFFSET);
+	priv->desc_free = &priv->desc[0];
+
+	for (i = 0; i < PACKAGE_NUM; ++i) {
+		priv->package_list[i].desc= &priv->desc[i];
+		INIT_LIST_HEAD(&priv->package_list[i].head);
+		{
+			struct transfer_data *desc_data;
+			desc_data= &priv->package_list[i];
+			printk("zz %s desc_data->head->prev:%08x desc_data->head->next:%08x \n",__func__, (int)desc_data->head.prev, (int)desc_data->head.next);
+		}
+		list_add_tail(&priv->package_list[i].head, &priv->free_list);
+	}
+
+	ndev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;
+	ndev->netdev_ops = &newam335x_netdev_ops;
+	ndev->ethtool_ops = &newam335x_netdev_tool;
+	priv->ndev = ndev;
+
+	//memcpy(ndev->dev_addr, priv->defaut_mac, ETH_ALEN);
+#if 0
+	random_ether_addr(priv->defaut_mac);
+#else
+	priv->defaut_mac[0] = 0xd0;
+	priv->defaut_mac[1] = 0x39;
+	priv->defaut_mac[2] = 0x72;
+	priv->defaut_mac[3] = 0x16;
+	priv->defaut_mac[4] = 0x73;
+	priv->defaut_mac[5] = 0xfb;
+#endif
+	netif_napi_add(ndev, &priv->napi_rx, eth_rx_poll, POLL_WEIGHT);
+	netif_tx_napi_add(ndev, &priv->napi_tx, eth_tx_poll, POLL_WEIGHT);
+
+	ether_addr_copy(ndev->dev_addr, priv->defaut_mac);
+	printk("mac: %02x:%02x:%02x:%02x:%02x:%02x \n",
+		priv->defaut_mac[0],
+		priv->defaut_mac[1],
+		priv->defaut_mac[2],
+		priv->defaut_mac[3],
+		priv->defaut_mac[4],
+		priv->defaut_mac[5]);
+	/* register the network device */
+	SET_NETDEV_DEV(ndev, &pdev->dev);
+
+	ret = register_netdev(ndev);
+	if (ret) {
+		dev_err(&pdev->dev, "error registering net device\n");
+		ret = -ENODEV;
+		goto error1;
+	}
+
+	netdev_info(ndev, "register newam335x eth successful\n");
+	return 0;
+
+error1:
+
+error:
+	return 0;
+}
+
+static int newam335x_eth_remove(struct platform_device *pdev)
+{
+  return 0;
+}
+
+static struct platform_driver newam335x_eth_driver = {
+  .driver = {
+	  .name    = "newam335x_eth_cpsw",
+	  .owner   = THIS_MODULE,
+	  //.pm    = &cpsw_pm_ops,
+	  //.of_match_table = cpsw_of_mtable,
+  },
+  .probe = newam335x_eth_probe,
+  .remove = newam335x_eth_remove,
+};
+
+module_platform_driver(newam335x_eth_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Cyril Chemparathy <cyril@ti.com>");
+MODULE_AUTHOR("Mugunthan V N <mugunthanvnm@ti.com>");
+MODULE_DESCRIPTION("TI CPSW Ethernet driver");
diff --git a/drivers/net/ethernet/newam335x/newam335x_eth_cpsw.h b/drivers/net/ethernet/newam335x/newam335x_eth_cpsw.h
new file mode 100644
index 0000000..97f6474
--- /dev/null
+++ b/drivers/net/ethernet/newam335x/newam335x_eth_cpsw.h
@@ -0,0 +1,193 @@
+#ifndef __NEWAM335X_ETH_CPSW_H__
+#define __NEWAM335X_ETH_CPSW_H__
+#include <linux/inetdevice.h>
+
+struct cpsw_ss_regs {
+	u32	id_ver;
+	u32	control;
+	u32	soft_reset;
+	u32	stat_port_en;
+	u32	ptype;
+};
+
+struct cpsw_port1_regs {
+	u32	max_blks;
+	u32	blk_cnt;
+	u32	flow_thresh;
+	u32	port_vlan;
+	u32	tx_pri_map;
+	u32	gap_thresh;
+	u32	sa_lo;
+	u32	sa_hi;
+};
+
+struct cpsw_port0_regs {
+	u32	max_blks;
+	u32	blk_cnt;
+	u32	flow_thresh;
+	u32	port_vlan;
+	u32	tx_pri_map;
+	u32	cpdma_tx_pri_map;
+	u32	cpdma_rx_chan_map;
+};
+
+struct cpsw_sl_regs {
+	u32	id_ver;
+	u32	mac_control;
+	u32	mac_status;
+	u32	soft_reset;
+	u32	rx_maxlen;
+	u32	__reserved_0;
+	u32	rx_pause;
+	u32	tx_pause;
+	u32	__reserved_1;
+	u32	rx_pri_map;
+};
+
+struct cpdma_desc {
+	/* hardware fields */
+	u32			hw_next;
+	u32			hw_buffer;
+	u32			hw_len;
+	u32			hw_mode;
+	/* software fields */
+	u32			sw_buffer;
+	u32			sw_len;
+};
+
+struct cpdma_chan {
+	//struct cpdma_desc	*head, *tail;
+	struct list_head list;
+	void *hdp, *cp, *rxfree;
+};
+
+struct cpsw_wr_regs {
+	u32	id_ver;
+	u32	soft_reset;
+	u32	control;
+	u32	int_control;
+	u32	rx_thresh_en;
+	u32	rx_en;
+	u32	tx_en;
+	u32	misc_en;
+	u32	mem_allign1[8];
+	u32	rx_thresh_stat;
+	u32	rx_stat;
+	u32	tx_stat;
+	u32	misc_stat;
+	u32	mem_allign2[8];
+	u32	rx_imax;
+	u32	tx_imax;
+
+};
+
+struct cpsw_hw_stats {
+	u32	rxgoodframes;
+	u32	rxbroadcastframes;
+	u32	rxmulticastframes;
+	u32	rxpauseframes;
+	u32	rxcrcerrors;
+	u32	rxaligncodeerrors;
+	u32	rxoversizedframes;
+	u32	rxjabberframes;
+	u32	rxundersizedframes;
+	u32	rxfragments;
+	u32	__pad_0[2];
+	u32	rxoctets;
+	u32	txgoodframes;
+	u32	txbroadcastframes;
+	u32	txmulticastframes;
+	u32	txpauseframes;
+	u32	txdeferredframes;
+	u32	txcollisionframes;
+	u32	txsinglecollframes;
+	u32	txmultcollframes;
+	u32	txexcessivecollisions;
+	u32	txlatecollisions;
+	u32	txunderrun;
+	u32	txcarriersenseerrors;
+	u32	txoctets;
+	u32	octetframes64;
+	u32	octetframes65t127;
+	u32	octetframes128t255;
+	u32	octetframes256t511;
+	u32	octetframes512t1023;
+	u32	octetframes1024tup;
+	u32	netoctets;
+	u32	rxsofoverruns;
+	u32	rxmofoverruns;
+	u32	rxdmaoverruns;
+};
+
+struct transfer_data {
+	void *skb;
+	struct cpdma_desc * desc;
+	struct list_head head;
+};
+
+#define PACKAGE_NUM (16)
+#define RX_PACKAGE_NUM (8)
+struct newam335x_eth_priv {
+	struct platform_device *pdev;
+	struct net_device	*ndev;
+	struct phy_device *phydev;
+	int phyaddr;
+	int phytype;
+	struct napi_struct napi_tx;
+	struct napi_struct napi_rx;
+	struct cpsw_ss_regs *ss_regs;
+	struct cpsw_sl_regs *sl1_regs;
+	struct cpsw_sl_regs *sl2_regs;
+	struct cpsw_port0_regs *port0_regs;
+	struct cpsw_port1_regs *port1_regs;
+	struct cpsw_port1_regs *port2_regs;
+	struct cpsw_wr_regs *wr_regs;
+	struct newam335x_mdio_regs *mdio_regs;
+	void *ale_regs;
+	void *dma_regs;
+	struct cpdma_desc *desc;
+	struct cpdma_desc		*desc_free;
+	struct cpdma_chan		rx_chan, tx_chan;
+	int rx_irq;
+	int tx_irq;
+	u8 defaut_mac[6];
+	struct transfer_data  package_list[PACKAGE_NUM];
+	struct list_head free_list;
+};
+
+#define CPPI_RAM_BASE 	(0x4A102000)
+#define CPPI_RAM_OFFSET (0x2000)
+#define CPSW_MDIO_OFFSET (0x1000)
+
+/*ADDRESS LOOKUP ENGINE ID/VERSION REGISTER */
+#define CPSW_ALE_IDVER  0x0
+/*ADDRESS LOOKUP ENGINE CONTROL REGISTER */
+#define CPSW_ALE_CONTROL  0x8
+/*ADDRESS LOOKUP ENGINE PRESCALE REGISTER */
+#define CPSW_ALE_PRESCALE  0x10
+/*ADDRESS LOOKUP ENGINE UNKNOWN VLAN*/
+#define CPSW_ALE_UNKNOWN_VLAN  0x18
+/*ADDRESS LOOKUP ENGINE TABLE CONTROL */
+#define CPSW_ALE_TBLCTL  0x20
+/*ADDRESS LOOKUP ENGINE TABLE WORD 2*/
+#define CPSW_ALE_TBLW2  0x34
+/*ADDRESS LOOKUP ENGINE TABLE WORD 1*/
+#define CPSW_ALE_TBLW1  0x38
+/*ADDRESS LOOKUP ENGINE TABLE WORD 0*/
+#define CPSW_ALE_TBLW0  0x3C
+/*ADDRESS LOOKUP ENGINE PORT 0 CONTROL*/
+#define CPSW_ALE_PORTCTL0  0x40
+/*ADDRESS LOOKUP ENGINE PORT 1 CONTROL*/
+#define CPSW_ALE_PORTCTL1  0x44
+/*ADDRESS LOOKUP ENGINE PORT 2 CONTROL*/
+#define CPSW_ALE_PORTCTL2  0x48
+/*ADDRESS LOOKUP ENGINE PORT 3 CONTROL*/
+#define CPSW_ALE_PORTCTL3  0x4C
+/*ADDRESS LOOKUP ENGINE PORT 4 CONTROL*/
+#define CPSW_ALE_PORTCTL4  0x50
+/*ADDRESS LOOKUP ENGINE PORT 5 CONTROL*/
+#define CPSW_ALE_PORTCTL5  0x54
+
+
+
+#endif /* ifndef __NEWAM335X_ETH_CPSW_H__ */
diff --git a/drivers/net/ethernet/newam335x/newam335x_mdio.c b/drivers/net/ethernet/newam335x/newam335x_mdio.c
new file mode 100644
index 0000000..04bbdce
--- /dev/null
+++ b/drivers/net/ethernet/newam335x/newam335x_mdio.c
@@ -0,0 +1,238 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/mdio.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include "newam335x_eth_cpsw.h"
+#include "newam335x_mdio.h"
+
+struct newam335x_mdio_regs {
+	u32	version;
+	u32	control;
+	u32	alive;
+	u32	link;
+	u32	linkintraw;
+	u32	linkintmasked;
+	u32	__reserved_0[2];
+	u32	userintraw;
+	u32	userintmasked;
+	u32	userintmaskset;
+	u32	userintmaskclr;
+	u32	__reserved_1[20];
+
+	struct {
+		u32		access;
+		u32		physel;
+	} user[0];
+};
+
+struct newam335x_mdio_priv
+{
+	struct mii_bus * mdio_bus;
+	struct newam335x_mdio_regs *mdio_regs;
+	struct platform_device *pdev;
+	struct device *dev;
+};
+
+#define MDIO_REGADDR_MASK (0x1f<<21)
+#define MDIO_PHYADDR_MASK (0x1f<<16)
+#define MDIO_REGADDR(val) ((val&0x1f)<<21)
+#define MDIO_PHYADDR(val) ((val&0x1f)<<16)
+#define MDIO_DATA(val) ((val&0xffff))
+#define MDIO_ACTIVE (1<<29)
+#define MDIO_ACK		BIT(29)
+#define MDIO_GO     (1<<31)
+#define MDIO_WR     (1<<30)
+#define CONTROL_IDLE		BIT(31)
+#define MDIO_DATA		(0xffff)
+
+/* wait until hardware is ready for another user access */
+static inline int wait_for_user_access(struct newam335x_mdio_priv *priv)
+{
+	unsigned long timeout = jiffies + 2*HZ;
+	u32 reg;
+
+	while (time_after(timeout, jiffies)) {
+
+		reg = __raw_readl(&priv->mdio_regs->user[0].access);
+
+		if ((reg & MDIO_GO) == 0)
+			return 0;
+
+		reg = __raw_readl(&priv->mdio_regs->control);
+		if ((reg & CONTROL_IDLE) == 0)
+			continue;
+
+		/*
+		 * An emac soft_reset may have clobbered the mdio controller's
+		 * state machine.  We need to reset and retry the current
+		 * operation
+		 */
+		//dev_warn(priv->dev, "resetting idled controller\n");
+		//__newam335x_mdio_reset(data);
+		//return -EAGAIN;
+	}
+
+	reg = __raw_readl(&priv->mdio_regs->user[0].access);
+	if ((reg & MDIO_GO) == 0)
+		return 0;
+
+	dev_err(priv->dev, "timed out waiting for user access\n");
+	return -ETIMEDOUT;
+}
+
+static int newam335x_mdio_read(struct mii_bus *bus, int phy_id, int phy_reg)
+{
+
+	struct newam335x_mdio_priv *priv = bus->priv;
+	struct newam335x_mdio_regs *mdio_regs = priv->mdio_regs;
+	u32 val, ret;
+	unsigned long start;
+
+	val = (MDIO_GO | (phy_reg << 21) |
+	       (phy_id << 16));
+
+	ret = wait_for_user_access(priv);
+	if (ret)
+		return -EINVAL;
+
+	__raw_writel(val, &mdio_regs->user[0].access);
+
+	ret = wait_for_user_access(priv);
+	if (ret)
+		return -EINVAL;
+
+	val = __raw_readl(&mdio_regs->user[0].access);
+	val = (val & MDIO_ACK) ? (val & MDIO_DATA) : -EIO;
+
+	dev_dbg(priv->dev, "read phy_id:%08x phy_reg:%08x val:%08x \n",phy_id, phy_reg, val);
+	return val;
+}
+
+static int newam335x_mdio_write(struct mii_bus *bus, int phy_id, int phy_reg, u16 phy_data)
+{
+	struct newam335x_mdio_priv *priv = bus->priv;
+	struct newam335x_mdio_regs *mdio_regs = priv->mdio_regs;
+	unsigned long start;
+	u32 val, ret;
+
+	val = (MDIO_GO | MDIO_WR | (phy_reg << 21) |
+	       (phy_id << 16) | (phy_data&MDIO_DATA));
+	
+	ret = wait_for_user_access(priv);
+	if (ret)
+		return -EINVAL;
+
+	writel(val, &mdio_regs->user[0].access);
+
+	ret = wait_for_user_access(priv);
+	if (ret)
+		return -EINVAL;
+	
+	dev_dbg(priv->dev, "write phy_id:%08x phy_reg:%08x val:%08x \n",phy_id, phy_reg, val);
+	return 0;
+}
+
+static void hw_mdio_init(struct newam335x_mdio_priv *priv)
+{
+#define MDIO_STATE_ENABLE 	(1<<30)
+#define MDIO_PREAMBLE  	  	(1<<20)
+	
+	struct newam335x_mdio_regs *mdio_regs;
+	u32 val;
+
+	mdio_regs = priv->mdio_regs;
+	writel(0xffffffff, &mdio_regs->alive);
+	val = readl(&mdio_regs->control);
+	val |= MDIO_STATE_ENABLE|MDIO_PREAMBLE;
+	writel(val, &mdio_regs->control);
+}
+
+static int newam335x_mdio_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct newam335x_mdio_priv *priv;
+	void __iomem *base;
+	int ret;
+
+	priv = kzalloc(sizeof(struct newam335x_mdio_priv), GFP_KERNEL);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "resource not find");
+		goto error;
+	}
+
+	base = ioremap(res->start, res->end - res->start);
+	if (!base) {
+		kfree(priv);
+		return -EINVAL;
+	}
+
+	priv->mdio_regs = (struct newam335x_mdio_regs*) base;
+	priv->pdev = pdev;
+	priv->dev = &pdev->dev;
+	platform_set_drvdata(pdev, priv);
+
+	priv->mdio_bus = mdiobus_alloc();
+	if (priv->mdio_bus == NULL)
+		return -ENOMEM;
+
+	priv->mdio_bus->name     = "newam335x mdio bus";
+	snprintf(priv->mdio_bus->id, MII_BUS_ID_SIZE, "%s",
+		priv->pdev->name);
+	priv->mdio_bus->priv     = priv;
+	priv->mdio_bus->parent   = &pdev->dev;
+	priv->mdio_bus->read     = &newam335x_mdio_read;
+	priv->mdio_bus->write    = &newam335x_mdio_write;
+	priv->mdio_bus->parent = &pdev->dev;
+	priv->mdio_bus->phy_mask = ~(1);
+
+	ret = mdiobus_register(priv->mdio_bus);
+	if (ret) {
+		return -ENOENT;
+	}
+
+	dev_info(&priv->mdio_bus->dev, "register\n");
+	return 0;
+error:
+	kfree(priv);
+	return 1;
+}
+
+static int newam335x_mdio_remove(struct platform_device *pdev)
+{
+	struct newam335x_mdio_priv *priv;
+	priv = platform_get_drvdata(pdev);
+	if (priv->mdio_bus) {
+		mdiobus_unregister(priv->mdio_bus);
+		mdiobus_free(priv->mdio_bus);
+		kfree(priv);
+	}
+	return 0;
+}
+
+static struct platform_driver newam335x_mdio_driver = {
+	.driver = {
+		.name	 = "newam335x_mdio",
+	},
+	.probe = newam335x_mdio_probe,
+	.remove = newam335x_mdio_remove,
+};
+
+static int __init newam335x_mdio_init(void)
+{
+	return platform_driver_register(&newam335x_mdio_driver);
+}
+device_initcall(newam335x_mdio_init);
+
+static void __exit newam335x_mdio_exit(void)
+{
+	platform_driver_unregister(&newam335x_mdio_driver);
+}
+module_exit(newam335x_mdio_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("newam335x MDIO driver");
diff --git a/drivers/net/ethernet/newam335x/newam335x_mdio.h b/drivers/net/ethernet/newam335x/newam335x_mdio.h
new file mode 100644
index 0000000..e69de29
-- 
1.9.1

