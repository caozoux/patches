From 15f67e16b77b6afaf8ece1d10f0b82dd1458de48 Mon Sep 17 00:00:00 2001
From: zou cao <cao.zou@windriver.com>
Date: Thu, 19 Oct 2017 16:30:57 +0800
Subject: [PATCH 31/34] newam335x: eth: ethernet work normall pass

Now we have fixed the ethernet packaged lost and tx halt

Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/net/ethernet/newam335x/Kconfig             |   1 -
 drivers/net/ethernet/newam335x/Makefile            |   2 +-
 drivers/net/ethernet/newam335x/ale.h               |   2 +-
 drivers/net/ethernet/newam335x/newam335x_debug.c   |  36 +-
 drivers/net/ethernet/newam335x/newam335x_debug.h   |   3 +-
 drivers/net/ethernet/newam335x/newam335x_eth_ale.c |  18 +-
 .../net/ethernet/newam335x/newam335x_eth_cpdam.c   | 273 +++++++++-----
 .../net/ethernet/newam335x/newam335x_eth_cpdam.h   |  18 +-
 .../net/ethernet/newam335x/newam335x_eth_cpsw.c    | 401 ++++++++++++---------
 .../net/ethernet/newam335x/newam335x_eth_cpsw.h    |  57 ++-
 10 files changed, 529 insertions(+), 282 deletions(-)

diff --git a/drivers/net/ethernet/newam335x/Kconfig b/drivers/net/ethernet/newam335x/Kconfig
index 67e8054..dde0419 100644
--- a/drivers/net/ethernet/newam335x/Kconfig
+++ b/drivers/net/ethernet/newam335x/Kconfig
@@ -5,5 +5,4 @@ config NET_VENDOR_NEWAM335X
 
 config NEWAM335X_ETH_CPSW
 	tristate "NEWAM335X CPSW Switch Support"
-	depends on ARCH_NEWAM335X
 	select PHYLIB
diff --git a/drivers/net/ethernet/newam335x/Makefile b/drivers/net/ethernet/newam335x/Makefile
index 6db0218..ee7b637 100644
--- a/drivers/net/ethernet/newam335x/Makefile
+++ b/drivers/net/ethernet/newam335x/Makefile
@@ -1,4 +1,4 @@
-ccflags-y := -DDEBUG
+#ccflags-y := -DDEBUG
 
 obj-$(CONFIG_NEWAM335X_ETH_CPSW) := newam335x_eth_drv.o
 newam335x_eth_drv-y  := newam335x_eth_cpsw.o newam335x_eth_ale.o newam335x_eth_cpdam.o newam335x_mdio.o newam335x_debug.o
diff --git a/drivers/net/ethernet/newam335x/ale.h b/drivers/net/ethernet/newam335x/ale.h
index fa59945..32fed39 100644
--- a/drivers/net/ethernet/newam335x/ale.h
+++ b/drivers/net/ethernet/newam335x/ale.h
@@ -34,6 +34,6 @@ enum cpsw_ale_port_state {
 int ale_init(struct newam335x_eth_priv *priv, unsigned char *addr);
 int cpsw_ale_add_mcast(struct newam335x_eth_priv *priv, const u8 *addr,int port_mask);
 void ale_dump(struct newam335x_eth_priv *priv);
-			      
+void add_default_vlan(struct newam335x_eth_priv *priv);
 #endif
 
diff --git a/drivers/net/ethernet/newam335x/newam335x_debug.c b/drivers/net/ethernet/newam335x/newam335x_debug.c
index 69c4ade..aded207 100644
--- a/drivers/net/ethernet/newam335x/newam335x_debug.c
+++ b/drivers/net/ethernet/newam335x/newam335x_debug.c
@@ -7,15 +7,47 @@
 #include <linux/device.h>
 #include "newam335x_eth_cpsw.h"
 #include "newam335x_eth_cpdam.h"
-#include <linux/newam335x_debug.h>
+//#include <linux/newam335x_debug.h>
 
+void dump_mem(void *addr, int len)
+{
+	int i, l;
+	int *buf = (int*)addr;
+	for (i = 0; i < len/4; i = i+16) {
+		printk("%08x: ", i*4);
+		for (l = 0;  l < 16; ++l) {
+			if ((i+l)>= len) {
+				printk("\n");
+				return;
+			}
+			printk("%08x ",buf[i+l]);
+		}
+		printk("\n");
+	}
+}
 
-void dump_skb(struct sk_buff *skb)
+void dump_skb(struct sk_buff *skb, int len)
 {
+	int i, l;
+	int off;
+	char *buf = (char*)skb->data;
 	printk("zz %s sdk->len:%08x \n",__func__, (int)skb->len);
 	printk("zz %s sdk->data_len:%08x \n",__func__, (int)skb->data_len);
 	printk("zz %s skb->mac_len:%08x \n",__func__, (int)skb->mac_len);
 	printk("zz %s skb->pkt_type:%08x \n",__func__, (int)skb->pkt_type);
+
+	for (i = 0; i < len; i = i+16) {
+		printk("%08x: ", i);
+		for (l = 0;  l < 16; ++l) {
+			if ((i+l)>= len) {
+				printk("\n");
+				return;
+			}
+			printk("%02x ",buf[i+l]);
+		}	
+		printk("\n");
+	}
+
 }
 
 
diff --git a/drivers/net/ethernet/newam335x/newam335x_debug.h b/drivers/net/ethernet/newam335x/newam335x_debug.h
index 115f68c..1ad42fd 100644
--- a/drivers/net/ethernet/newam335x/newam335x_debug.h
+++ b/drivers/net/ethernet/newam335x/newam335x_debug.h
@@ -1,6 +1,7 @@
 #ifndef __NEWAM335X_DEBUG_H__
 #define __NEWAM335X_DEBUG_H__
 
-void dump_skb(struct sk_buff *skb);
+void dump_skb(struct sk_buff *skb, int len);
+void dump_mem(void *addr, int len);
 
 #endif /* ifndef __NEWAM335X_DEBUG_H__ */
diff --git a/drivers/net/ethernet/newam335x/newam335x_eth_ale.c b/drivers/net/ethernet/newam335x/newam335x_eth_ale.c
index e3d8c05..d22904b 100644
--- a/drivers/net/ethernet/newam335x/newam335x_eth_ale.c
+++ b/drivers/net/ethernet/newam335x/newam335x_eth_ale.c
@@ -154,6 +154,8 @@ int cpsw_ale_add_mcast(struct newam335x_eth_priv *priv, const u8 *addr,
 		return -ENOMEM;
 	}
 
+	printk("zz %s idx:%08x ale_entry[0]:%08x \ale_entry[0]:%08x \ale_entry[0]:%08x \n",__func__,
+			(int)idx, ale_entry[0], ale_entry[1], ale_entry[2]);
 	cpsw_ale_write(priv, idx, ale_entry);
 
 	return 0;
@@ -171,7 +173,7 @@ int ale_init(struct newam335x_eth_priv *priv, u8 *addr)
 		ale_bit_set(ale_entry, 40 - 8*i, 8, addr[i]);
 
 	ale_bit_set(ale_entry, ALEBIT_UCAST_TYPE, 2 , ALE_UCAST_PERSISTANT);
-	ale_bit_set(ale_entry, ALEBIT_SECIRE, 1, 1);
+	ale_bit_set(ale_entry, ALEBIT_SECIRE, 1, 0);
 	ale_bit_set(ale_entry, ALEBIT_BLOCKED, 1, 0);
 	ale_bit_set(ale_entry, ALEBIT_PORT_NUM, 2, 0);
 
@@ -185,10 +187,12 @@ int ale_init(struct newam335x_eth_priv *priv, u8 *addr)
 		return -ENOMEM;
 	}
 
+	printk("zz %s idx:%08x ale_entry[0]:%08x \ale_entry[0]:%08x \ale_entry[0]:%08x \n",__func__,
+			(int)idx, ale_entry[0], ale_entry[1], ale_entry[2]);
 	//add the ucase addr
 	cpsw_ale_write(priv, idx, ale_entry);
 	
-	cpsw_ale_add_mcast(priv, net_bcast_ethaddr, 1<<1);
+	cpsw_ale_add_mcast(priv, net_bcast_ethaddr, 1);
 
 	return 0;
 }
@@ -203,3 +207,13 @@ void update_ale_port(struct newam335x_eth_priv *priv, int port, int val)
 	tmp |= val & mask;
 	__raw_writel(tmp, priv->ale_regs + offset);
 }
+
+void add_default_vlan(struct newam335x_eth_priv *priv)
+{
+	u32 ale_entry[3] = {0, 0, 0};
+	ale_entry[0] = 0x00000000;
+	ale_entry[1] = 0x20000000;
+	ale_entry[2] = 0x07070607;
+
+	cpsw_ale_write(priv, 2, ale_entry);
+}
diff --git a/drivers/net/ethernet/newam335x/newam335x_eth_cpdam.c b/drivers/net/ethernet/newam335x/newam335x_eth_cpdam.c
index e34702d..b60d9d5 100644
--- a/drivers/net/ethernet/newam335x/newam335x_eth_cpdam.c
+++ b/drivers/net/ethernet/newam335x/newam335x_eth_cpdam.c
@@ -7,7 +7,7 @@
 #include <linux/device.h>
 #include "newam335x_eth_cpsw.h"
 #include "newam335x_eth_cpdam.h"
-#include <linux/newam335x_debug.h>
+//#include <linux/newam335x_debug.h>
 
 void loop_dealy(int ms)
 {
@@ -20,6 +20,10 @@ void loop_dealy(int ms)
 	}
 }
 
+void newam335x_cpdma_status_dump(struct newam335x_eth_priv *priv)
+{
+}
+
 void newam335x_cpdma_dump(struct newam335x_eth_priv *priv, struct cpdma_desc *desc)
 {
 	printk("zz %s desc:%08x \n",__func__, (int)desc);
@@ -27,139 +31,223 @@ void newam335x_cpdma_dump(struct newam335x_eth_priv *priv, struct cpdma_desc *de
 	printk("hw_buffer:%08x \n",desc_read(desc, hw_buffer));
 	printk("hw_len:%08x \n",desc_read(desc, hw_len));
 	printk("hw_mode:%08x \n",desc_read(desc, hw_mode));
+	printk("token:%08x \n",desc_read(desc, token));
 	printk("sw_buffer:%08x \n",desc_read(desc, sw_buffer));
 	printk("sw_len:%08x \n",desc_read(desc, sw_len));
 	printk("dma_status:%08x \n",__raw_readl(priv->dma_regs+0x24));
-	printk("dma_tx_pend:%08x \n",__raw_readl(priv->dma_regs+0x80));
-	printk("wr_rx_status:%08x \n",__raw_readl((void*)priv->wr_regs+0x44));
-	printk("wr_tx_status:%08x \n",__raw_readl((void*)priv->wr_regs+0x48));
-	newam335x_interrupt_debug(58);
+	//printk("dma_tx_pend:%08x \n",__raw_readl(priv->dma_regs+0x80));
+	//printk("wr_rx_status:%08x \n",__raw_readl((void*)priv->wr_regs+0x44));
+	//printk("wr_tx_status:%08x \n",__raw_readl((void*)priv->wr_regs+0x48));
 }
 
 void newam335x_cpdma_rx_state(struct newam335x_eth_priv *priv)
 {
-	struct cpdma_desc *desc;
-	struct cpdma_chan *chan;
-	struct transfer_data * desc_data, *desc_data_head;
-	u32 status, len;
-
-	chan = &priv->rx_chan;
-
-	desc_data = list_first_entry(&chan->list, struct transfer_data, head);
-	desc = desc_data->desc;
-		
-	while(1) {
-		desc_data = list_first_entry(&chan->list, struct transfer_data, head);
-		desc = desc_data->desc;
-		
-		loop_dealy(5000);
-		list_for_each_entry(desc_data, &chan->list, head) {
-			newam335x_cpdma_dump(priv, desc_data->desc);
-		}
-	}
+	printk("CPDMA_RX_INT_STATE:%08x \n",__raw_readl(priv->dma_regs+CPDMA_RX_INT_STATE));
+	printk("CPDMA_DMA_INT_STATE:%08x \n",__raw_readl(priv->dma_regs+CPDMA_DMA_INT_STATE));
 }
 
-struct transfer_data * cpdma_alloc(struct newam335x_eth_priv *priv)
+inline dma_addr_t descvir_to_phy(struct cpdma_desc_pool *pool, struct cpdma_desc *desc)
 {
-	struct transfer_data  *desc_data;
+	if (!desc)
+		return 0;
+
+	return (dma_addr_t) ((void*)desc- pool->pool_vir + pool->pool_phy);
+}
 
-	if (list_empty(&priv->free_list))
+inline struct cpdma_desc *descphy_to_vir(struct cpdma_desc_pool *pool, dma_addr_t addr)
+{
+	if (!addr)
 		return NULL;
 
-	desc_data = list_first_entry(&priv->free_list, struct transfer_data, head);
-	if (desc_data) {
-		//list_del(&desc_data->head);
-		list_del_init(&desc_data->head);
-		return desc_data;
+	return (struct cpdma_desc*) ((void*)addr - (void*)pool->pool_phy + (void*)pool->pool_vir);
+}
+
+int newam335x_cpdma_pool_create(struct newam335x_eth_priv *priv)
+{
+	int bitsize;
+	int number;
+	struct cpdma_desc_pool *pool;
+	bitsize = 0x2000/sizeof(struct cpdma_desc);
+	number = bitsize;
+	bitsize = bitsize%sizeof(long)+1;
+
+	priv->pool = pool = devm_kzalloc(priv->dev, sizeof(struct cpdma_desc_pool), GFP_KERNEL);
+	pool->bitmap = devm_kzalloc(priv->dev, bitsize, GFP_KERNEL);
+	pool->pool_vir  = priv->dma_ram;
+	pool->pool_phy = CPPI_RAM_BASE;
+	pool->number = number;
+	spin_lock_init(&pool->lock);
+
+	return 0;
+}
+
+struct cpdma_desc* cpdma_alloc(struct newam335x_eth_priv *priv, struct cpdma_chan *chan)
+{
+	struct cpdma_desc *desc = NULL;
+	struct cpdma_desc_pool *pool = priv->pool;
+	int desc_end, desc_start;
+	unsigned long flags;
+	int index;
+
+	desc_start = chan->start_number;
+	desc_end = chan->end_number;
+
+	spin_lock_irqsave(&pool->lock, flags);
+	index = bitmap_find_next_zero_area(pool->bitmap,
+				desc_end, desc_start, 1, 0);
+
+	if (index < desc_end) {
+		desc = pool->pool_vir + sizeof(struct cpdma_desc)*index;
+		bitmap_set(pool->bitmap, index, 1);
 	}
+	spin_unlock_irqrestore(&pool->lock, flags);
 
-	return NULL;
+	return desc;
 }
 
-void cpdma_free(struct newam335x_eth_priv *priv, struct transfer_data *desc_data)
+void cpdma_free(struct newam335x_eth_priv *priv, struct cpdma_chan *chan, struct cpdma_desc *desc)
 {
-	if (desc_data)
-		list_add_tail(&desc_data->head, &priv->free_list);
+	struct cpdma_desc_pool *pool = priv->pool;
+	int index;
+	unsigned long flags;
+	
+	spin_lock_irqsave(&pool->lock, flags);
+	index = ((void*)desc - pool->pool_vir)/sizeof(struct cpdma_desc);
+	bitmap_clear(pool->bitmap, index, 1);
+	spin_unlock_irqrestore(&pool->lock, flags);
 }
 
+
 int cpdma_eoi_write(struct newam335x_eth_priv *priv, int val)
 {
 	__raw_writel(val, priv->dma_regs+ CPDMA_EIO_VECT);
+	return 0;
 }
 
-int cpdma_submit(struct newam335x_eth_priv *priv, struct sk_buff *skb, bool isTx)
+int cpdma_handle_chan(struct newam335x_eth_priv *priv, struct cpdma_chan *chan)
+{
+	struct cpdma_desc *desc;
+	struct sk_buff *skb;
+	unsigned long flags;
+	unsigned int status;
+	dma_addr_t addr;
+	u32 len, origlen;
+	int cnt = 0;
+
+	while (chan->head) {
+		spin_lock_irqsave(&chan->lock, flags);
+		desc = chan->head;
+		status = desc_read(desc, hw_mode);
+		if (status & CPDMA_DESC_OWNER) {
+			dev_dbg(priv->dev, "zz %s %d BUSY\n", __func__, __LINE__);
+			spin_unlock_irqrestore(&chan->lock, flags);
+			goto out;
+		} else {
+			skb = (struct sk_buff *) desc->token;
+			len = status & 0x7ff;
+
+			if (status & CPDMA_DESC_PASS_CRC)
+				len -= CPDMA_DESC_CRC_LEN;
+
+			status	= status & (CPDMA_DESC_EOQ | CPDMA_DESC_TD_COMPLETE |
+						CPDMA_DESC_PORT_MASK);
+
+			/*last desc*/
+			if (status & CPDMA_DESC_EOQ) {
+				dev_dbg(priv->dev, "zz %s %d EOQ\n", __func__, __LINE__);
+				//chan_write(chan, cp, descvir_to_phy(priv->pool, desc));
+				//cpdma_eoi_write(priv, chan->eio_val);
+			}
+
+			addr = desc_read(desc, hw_buffer);
+			origlen = desc_read(desc, sw_len);
+			dma_unmap_single(priv->dev, addr, origlen, chan->dir);
+			chan->head = descphy_to_vir(priv->pool, desc->hw_next);
+
+			chan_write(chan, cp, descvir_to_phy(priv->pool, desc));
+			spin_unlock_irqrestore(&chan->lock, flags);
+			//newam335x_cpdma_dump(priv, desc);
+			cpdma_free(priv, chan, desc);
+			if (chan->handle)
+				chan->handle(priv, skb, len);
+			cnt++;
+		}
+	}
+
+out:
+	return cnt;
+}
+
+/*
+ * port 0: recv packet
+ * port 1: send packet
+ */
+int cpdma_submit(struct newam335x_eth_priv *priv, struct cpdma_chan *chan, struct sk_buff *skb, int port)
 {
 	struct cpdma_desc *desc, *prev;
-	struct transfer_data *desc_data, *prev_data;
-	struct cpdma_chan *chan;
+	unsigned long flags;
 	dma_addr_t dma_addr;
-	u32 mode, start, ret, len;
+	u32 mode, ret, len;
 
-	desc_data = cpdma_alloc(priv);
-	if (!desc_data) {
+	spin_lock_irqsave(&chan->lock, flags);
+	desc= cpdma_alloc(priv, chan);
+	if (!desc) {
 		printk("Error: no desc to alloc\n");
 		return -ENOMEM;
 	}
 
-	if (isTx) {
-		chan = &priv->tx_chan;
-		dma_addr = dma_map_single(&priv->pdev->dev, skb->data, skb->len, DMA_TO_DEVICE);
-	} else {
-		dma_addr = dma_map_single(&priv->pdev->dev, skb->data, skb->len, DMA_FROM_DEVICE);
-		chan = &priv->rx_chan;
-	}
+	dma_addr = dma_map_single(&priv->pdev->dev, skb->data, skb->len, chan->dir);
 
 	ret = dma_mapping_error(&priv->pdev->dev, dma_addr);
 	if (ret)
 		dev_err(&priv->pdev->dev, "dma map failed\n");
 
 	len=skb->len;
-	desc_data->skb = skb;
-	desc = desc_data->desc;
-	printk("zz %s desc:%08x \n",__func__, DESC_PHYADDR(priv, desc));
+	if (len < chan->min_len)
+		len = chan->min_len;
+
+	//printk("zz %s desc:%08x \n",__func__, DESC_PHYADDR(priv, desc));
 
 	mode = CPDMA_DESC_OWNER | CPDMA_DESC_SOP | CPDMA_DESC_EOP;
+	//mode |= (CPDMA_DESC_TO_PORT_EN | (port << CPDMA_TO_PORT_SHIFT));
+		 
 	desc_write(desc, hw_next,   0);
 	desc_write(desc, hw_buffer, dma_addr);
 	desc_write(desc, hw_len,    len);
 	desc_write(desc, hw_mode,   mode | len);
-	desc_write(desc, sw_buffer, desc_data);
+	desc_write(desc, token, skb);
+	desc_write(desc, sw_buffer, skb->data);
 	desc_write(desc, sw_len,    len);
 
 	if (len < PKT_MIN)
 		len = PKT_MIN;
 
-	if (list_empty(&chan->list)) {
+	if (!chan->head) {
 		/* simple case - first packet enqueued */
-		list_add_tail(&desc_data->head, &chan->list);
-		chan_write(chan, hdp, DESC_PHYADDR(priv, desc));
-
+		chan->head=desc;
+		chan->tail=desc;
+		chan_write(chan, hdp, descvir_to_phy(priv->pool, desc));
 		goto done;
 	}
 	
 	/* not the first packet - enqueue at the tail */
-	prev_data = list_last_entry(&chan->list, struct transfer_data, head);
-	prev = prev_data->desc;
-	desc_write(prev, hw_next, DESC_PHYADDR(priv, desc));
-	list_add_tail(&desc_data->head, &chan->list);
+	prev = chan->tail;
+	desc_write(prev, hw_next, descvir_to_phy(priv->pool, desc));
+	chan->tail = desc;
 
 	/* next check if EOQ has been triggered already */
-	if (desc_read(prev, hw_mode) & CPDMA_DESC_EOQ)
-		chan_write(chan, hdp, DESC_PHYADDR(priv, desc));
+	mode = desc_read(prev, hw_mode);
+	if (((mode & (CPDMA_DESC_EOQ | CPDMA_DESC_OWNER)) == CPDMA_DESC_EOQ)) {
+		printk("zz %s %d eoq triger\n", __func__, __LINE__);
+		desc_write(prev, hw_mode, mode & ~CPDMA_DESC_EOQ);
+		chan_write(chan, hdp, descvir_to_phy(priv->pool, desc));
+	}
 
 done:
-
-#if 0
-	if(isTx) {
-		while(1) {
-			loop_dealy(1000);
-			newam335x_cpdma_dump(priv, desc);
-		}
-	}
-#endif
 	if (chan->rxfree)
 		chan_write(chan, rxfree, 1);
 
+	spin_unlock_irqrestore(&chan->lock, flags);
 	return 0;
 }
 
@@ -175,20 +263,39 @@ void cpdma_enable(struct newam335x_eth_priv *priv, bool enable)
 	//newam335x_cpdma_rx_state(priv);
 }
 
-void newam335x_cpdam_init(struct newam335x_eth_priv *priv)
+int newam335x_cpdam_init(struct newam335x_eth_priv *priv, desc_handle_callback tx_handle, desc_handle_callback rx_handle)
 {
-	u32 val;
-	long start;
-	int i, ret;
+	int ret, val;
+	unsigned long start;
+	int i;
 
-	INIT_LIST_HEAD(&priv->tx_chan);
+	newam335x_cpdma_pool_create(priv);
 	priv->tx_chan.hdp       = priv->dma_regs + CPDMA_TXHDP_VER2;
 	priv->tx_chan.cp        = priv->dma_regs + CPDMA_TXCP_VER2;
+	priv->tx_chan.head = priv->tx_chan.tail = NULL;
+	priv->tx_chan.rxfree    = NULL;
+	priv->tx_chan.dir = DMA_TO_DEVICE;
+	//priv->tx_chan.start_number =  priv->pool->number/2;
+	//priv->tx_chan.end_number =  priv->pool->number;
+	priv->tx_chan.start_number =  65;
+	priv->tx_chan.end_number =  130;
+	priv->tx_chan.eio_val =  2;
+	priv->tx_chan.handle = tx_handle;
+	priv->tx_chan.min_len = 60;
+	spin_lock_init(&priv->tx_chan.lock);
 
-	INIT_LIST_HEAD(&priv->rx_chan);
 	priv->rx_chan.hdp       = priv->dma_regs + CPDMA_RXHDP_VER2;
 	priv->rx_chan.cp        = priv->dma_regs + CPDMA_RXCP_VER2;
 	priv->rx_chan.rxfree    = priv->dma_regs + CPDMA_RXFREE;
+	priv->rx_chan.head = priv->tx_chan.tail = NULL;
+	priv->rx_chan.dir = DMA_FROM_DEVICE;
+	priv->rx_chan.start_number =  0;
+	//priv->rx_chan.end_number =  priv->pool->number/2;
+	priv->rx_chan.end_number =  64;
+	priv->rx_chan.eio_val =  1;
+	priv->rx_chan.handle = rx_handle;
+	priv->tx_chan.min_len = 60;
+	spin_lock_init(&priv->rx_chan.lock);
 
 	__raw_writel(0, priv->dma_regs + CPDMA_TXCONTROL);
 	__raw_writel(0, priv->dma_regs + CPDMA_RXCONTROL);
@@ -199,17 +306,12 @@ void newam335x_cpdam_init(struct newam335x_eth_priv *priv)
 	do  {
 		if (time_after(jiffies, start)) {
 			printk("Error: reset cpdma failed");
-			return;
+			return 1;
 		}
 		val = __raw_readl(priv->dma_regs + CPDMA_SOFTRESET);
 		msleep(1);
 	} while((val&1) == 1);
 
-	for (i = 0; i < CPDMA_DESC_NUM; i++) {
-		desc_write(&priv->desc[i], hw_next,
-			   (i == (CPDMA_DESC_NUM - 1)) ? 0 : &priv->desc[i+1]);
-	}
-
 	for (i = 0; i < 8; i++) {
 		__raw_writel(0, priv->dma_regs + CPDMA_RXHDP_VER2 + 4*i);
 		__raw_writel(0, priv->dma_regs + CPDMA_RXFREE + 4*i);
@@ -219,6 +321,7 @@ void newam335x_cpdam_init(struct newam335x_eth_priv *priv)
 	}
 
 	__raw_writel(0xff, priv->dma_regs + CPDMA_TX_CLR_MASK);
-	__raw_writel(0xff, priv->dma_regs + CPDMA_RX_CLR_MASK);
+	__raw_writel(0x01, priv->dma_regs + CPDMA_RX_CLR_MASK);
+	return 0;
 }
 
diff --git a/drivers/net/ethernet/newam335x/newam335x_eth_cpdam.h b/drivers/net/ethernet/newam335x/newam335x_eth_cpdam.h
index fe41483..9b6b5f3 100644
--- a/drivers/net/ethernet/newam335x/newam335x_eth_cpdam.h
+++ b/drivers/net/ethernet/newam335x/newam335x_eth_cpdam.h
@@ -10,20 +10,29 @@
 /* DMA Registers */
 #define CPDMA_TXCONTROL		0x004
 #define CPDMA_RXCONTROL		0x014
+#define CPDMA_DMA_STATUS    0x024
 #define CPDMA_SOFTRESET		0x01c
 #define CPDMA_RXFREE		0x0e0
 #define CPDMA_TX_CLR_MASK   0x88
 #define CPDMA_TX_SET_MASK   0x8c
+#define CPDMA_RX_INT_STATE      0xa0
 #define CPDMA_RX_CLR_MASK   0xa8
 #define CPDMA_RX_SET_MASK   0xac
 #define CPDMA_IN_VECT 	    0x90
 #define CPDMA_EIO_VECT 	    0x94
+#define CPDMA_DMA_INT_STATE      0xb0
 
 /* Descriptor mode bits */
 #define CPDMA_DESC_SOP		(1<<31)
 #define CPDMA_DESC_EOP		(1<<30)
 #define CPDMA_DESC_OWNER	(1<<29)
 #define CPDMA_DESC_EOQ		(1<<28)
+#define CPDMA_DESC_TD_COMPLETE	(1<<27)
+#define CPDMA_DESC_PASS_CRC	(1<<26)
+#define CPDMA_DESC_TO_PORT_EN	BIT(20)
+#define CPDMA_DESC_PORT_MASK	(7<<16)
+#define CPDMA_TO_PORT_SHIFT	16
+#define CPDMA_DESC_CRC_LEN	4
 
 #define PKTBUFSRX 8
 #define PKT_MIN			60
@@ -40,12 +49,15 @@
 
 #define DESC_PHYADDR(priv, DESC) (((void*)DESC-(void*)&priv->desc[0])+CPPI_RAM_BASE)
 
-void newam335x_cpdam_init(struct newam335x_eth_priv *priv);
-int cpdma_submit(struct newam335x_eth_priv *priv, struct sk_buff *skb, bool isTx);
+int newam335x_cpdma_pool_create(struct newam335x_eth_priv *priv);
+int newam335x_cpdam_init(struct newam335x_eth_priv *priv, desc_handle_callback tx_handle, desc_handle_callback rx_handle);
+int cpdma_handle_chan(struct newam335x_eth_priv *priv, struct cpdma_chan *chan);
+int cpdma_submit(struct newam335x_eth_priv *priv, struct cpdma_chan *chan, struct sk_buff *skb, int port);
 void cpdma_enable(struct newam335x_eth_priv *priv, bool enable);
 int cpdma_eoi_write(struct newam335x_eth_priv *priv, int val);
 int handle_cpdma_desc(struct newam335x_eth_priv *priv, bool isTx);
-void cpdma_free(struct newam335x_eth_priv *priv, struct transfer_data *desc_data);
+void cpdma_free(struct newam335x_eth_priv *priv, struct cpdma_chan *chan, struct cpdma_desc *desc);
 void newam335x_cpdma_dump(struct newam335x_eth_priv *priv, struct cpdma_desc *desc);
+void newam335x_cpdma_rx_state(struct newam335x_eth_priv *priv);
 #endif /* ifndef __NEWMA335X_ETH_CPDMA_H__ */
 
diff --git a/drivers/net/ethernet/newam335x/newam335x_eth_cpsw.c b/drivers/net/ethernet/newam335x/newam335x_eth_cpsw.c
index ce53e5a..784cb51 100644
--- a/drivers/net/ethernet/newam335x/newam335x_eth_cpsw.c
+++ b/drivers/net/ethernet/newam335x/newam335x_eth_cpsw.c
@@ -30,7 +30,7 @@
 #include "newam335x_eth_cpdam.h"
 #include "newam335x_debug.h"
 #include "ale.h"
-
+#define CPSW_MIN_PACKET_SIZE    60
 #define CPSW_MAX_PACKET_SIZE	(1500 + 14 + 4 + 4)
 #define POLL_WEIGHT (64)
 #define NEWAM335X_CPSW_MAX_QUEUES 8
@@ -40,7 +40,8 @@
 #define mac_lo(mac) (((mac)[4] << 0) | ((mac)[5] << 8))
 
 int queue_rx_packages(struct newam335x_eth_priv *priv);
-static int handle_rx_package(struct newam335x_eth_priv *priv);
+static int handle_rx_package(struct newam335x_eth_priv *priv, struct sk_buff *skb, int len);
+static int handle_tx_package(struct newam335x_eth_priv *priv, struct sk_buff *skb, int len);
 
 int gen_get_settings(struct net_device *netdev, struct ethtool_cmd *cmd)
 {   
@@ -99,7 +100,7 @@ int gen_set_ringparam(struct net_device *netdev,
 /* Set a self-clearing bit in a register, and wait for it to clear */
 static int setbit_and_wait_for_clear32(void *addr)
 {
-	long timeout = jiffies + 4*HZ;
+	unsigned long timeout = jiffies + 4*HZ;
 
 	__raw_writel(1, addr);
 	while (__raw_readl(addr) & 1) {
@@ -116,16 +117,16 @@ static void newam335x_slave_init(struct newam335x_eth_priv *priv, int port)
 	const u8 net_bcast_ethaddr[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 	struct cpsw_sl_regs *slave;
 	struct cpsw_port1_regs *port_reg;
-	int offset = CPSW_ALE_PORTCTL0+ 4 * port;
-	u32 val;
-	u32 tmp, mask = 0x3;
 
-	if (port == 0) {
+	if (port == 1) {
 		slave = priv->sl1_regs;
 		port_reg = (struct cpsw_port1_regs *)priv->port1_regs;
-	} else if (port == 1) {
+	} else if (port == 2) {
 		slave = priv->sl2_regs;
 		port_reg = priv->port2_regs;
+	} else {
+		dev_err(priv->dev, "error port not support\n");
+		return;
 	}
 	
 	setbit_and_wait_for_clear32(&slave->soft_reset);
@@ -139,13 +140,9 @@ static void newam335x_slave_init(struct newam335x_eth_priv *priv, int port)
 	__raw_writel(mac_hi(priv->defaut_mac), &port_reg->sa_hi);
 	__raw_writel(mac_lo(priv->defaut_mac), &port_reg->sa_lo);
 
-	/* enable forwarding */
-	update_ale_port (priv, port+1, ALE_PORT_STATE_FORWARD);
-
-	cpsw_ale_add_mcast(priv, net_bcast_ethaddr, 1);
-
+	cpsw_ale_add_mcast(priv, net_bcast_ethaddr, 1<<port);
 
-	__raw_writel(1|1<<15|1<<5, &slave->mac_control);
+	//__raw_writel(1|1<<15|1<<5, &slave->mac_control);
 }
 
 /*
@@ -155,54 +152,71 @@ static void newam335x_interrupt_init(struct newam335x_eth_priv *priv)
 {
 #define WR_CONTORL_PLUS_EN(val)  (val<<16)
 	struct cpsw_wr_regs *wr_regs = priv->wr_regs;
-	u32 val;
 
 	//setbit_and_wait_for_clear32(&wr_regs->soft_reset);
 
 	/*enable dma chanle 0 interrupt*/
 	__raw_writel(0x1, &wr_regs->rx_en);
-	__raw_writel(0x1, &wr_regs->tx_en);
+	__raw_writel(0xff, &wr_regs->tx_en);
 
 }
 
 static int newam335x_eth_init(struct net_device *ndev)
 {
-	u32 start;
-	u32 val;
 	struct newam335x_eth_priv *priv = (struct newam335x_eth_priv *) netdev_priv(ndev);
+	u32 control_reg;
+	u32 val;
+	int ret;
 
 	setbit_and_wait_for_clear32(&priv->ss_regs->soft_reset);
 
-	//writel(readl(&priv->ale_regs+CPSW_ALE_CONTROL) & ~(1<<2),
-	//		priv->ale_regs+CPSW_ALE_CONTROL);  /* vlan unaware mode */
+	//enable ale
 	val = readl(priv->ale_regs+CPSW_ALE_CONTROL);
 	val |= 1<<31;
 	writel(val, priv->ale_regs+CPSW_ALE_CONTROL);
+	val = readl(priv->ale_regs+CPSW_ALE_CONTROL);
 	val |= 1<<30;
 	writel(val, priv->ale_regs+CPSW_ALE_CONTROL);
+#if 1
+	//enable ale vlan aware
+	val = readl(priv->ale_regs+CPSW_ALE_CONTROL);
+	val |= (1<<2);
+	writel(val, priv->ale_regs+CPSW_ALE_CONTROL);
+
+	//vlan aware
+	control_reg = readl(&priv->ss_regs->control);
+	control_reg |= CPSW_VLAN_AWARE;
+	writel(control_reg, &priv->ss_regs->control);
+#endif
+	writel(0, &priv->port0_regs->tx_in_ctl);
 
 	/* setup host port priority mapping */
 	__raw_writel(0x76543210, &priv->port0_regs->cpdma_tx_pri_map);
 	__raw_writel(0, &priv->port0_regs->cpdma_rx_chan_map);
 
+	ale_init(priv, priv->defaut_mac);
+	newam335x_slave_init(priv, 1);
+	add_default_vlan(priv);
+
 	/* disable priority elevation and enable statistics on all ports */
 	__raw_writel(0, &priv->ss_regs->ptype);
 
 	/* enable statistics collection only on the host port */
-	__raw_writel(1, &priv->ss_regs->stat_port_en);
 	__raw_writel(0x7, &priv->ss_regs->stat_port_en);
-
+	/* Enable internal fifo flow control */
+	writel(0x7, &priv->ss_regs->flow_control);
 	update_ale_port(priv, 0, ALE_PORT_STATE_FORWARD);
 
-	ale_init(priv, priv->defaut_mac);
-
-	newam335x_slave_init(priv, 0);
+	ret = newam335x_cpdam_init(priv, handle_tx_package, handle_rx_package);
+	if (ret)
+		return ret;
 
-	newam335x_cpdam_init(priv);
+	queue_rx_packages(priv);
+	cpdma_enable(priv, true);
 
 	newam335x_interrupt_init(priv);
+	priv->mac_control = 0;
 
-	queue_rx_packages(priv);
 #if 0
 	newam335x_phy_init(dev);
 	phy_startup(priv->phydev);
@@ -216,14 +230,36 @@ static void eth_adjust_link(struct net_device *ndev)
 {
 	struct newam335x_eth_priv *priv = (struct newam335x_eth_priv *) netdev_priv(ndev);
 	struct phy_device *phydev = priv->phydev;
+	u32			mac_control = 0;
 
-	printk("zz %s %d link:%d\n", __func__, __LINE__, phydev->link);
 
 	if (phydev->link) {
+		update_ale_port(priv, 1, ALE_PORT_STATE_FORWARD);
+		if (phydev->speed == 1000)
+			mac_control |= BIT(7);	/* GIGABITEN	*/
+		if (phydev->duplex)
+			mac_control |= BIT(0);	/* FULLDUPLEXEN	*/
+
+		/* set speed_in input in case RMII mode is used in 100Mbps */
+		if (phydev->speed == 100)
+			mac_control |= BIT(15);
+		else if (phydev->speed == 10)
+			mac_control |= BIT(18); /* In Band mode */
+
+		mac_control |= 0x20;
+		if (priv->mac_control != mac_control)
+			__raw_writel(mac_control|0x20, &priv->sl1_regs->mac_control);
+
 		netif_carrier_on(ndev);
-		cpdma_enable(priv, true);
+		if (netif_running(ndev))
+			netif_wake_queue(ndev);
 	} else {
-		//cpdma_enable(priv, false);
+		mac_control = 0;
+		__raw_writel(mac_control, &priv->sl1_regs->mac_control);
+	}
+	if (priv->mac_control != mac_control) {
+		dev_info(priv->dev, "link is %s\n", phydev->link?"up":"down");
+		priv->mac_control = mac_control;
 	}
 }
 
@@ -232,26 +268,32 @@ static int cpsw_ndo_open(struct net_device *ndev)
 	struct newam335x_eth_priv *priv = (struct newam335x_eth_priv *) netdev_priv(ndev);
 	struct phy_device *phydev;
 	char phy_id[MII_BUS_ID_SIZE + 3];
+	int ret;
 
-	printk("zz %s %d \n", __func__, __LINE__);
-
-	newam335x_eth_init(ndev);
+	ret = newam335x_eth_init(ndev);
+	if (ret) {
+		dev_err(priv->dev, "eth init failed\n");
+		return -ENXIO;
+	}
 
 	snprintf(phy_id, sizeof(phy_id), PHY_ID_FMT,
 		 "newam335x_mdio", 0);
 	phydev = phy_connect(ndev, phy_id, eth_adjust_link,
 	 			PHY_INTERFACE_MODE_MII);
-
 	if (IS_ERR(phydev)) {
 		netdev_err(ndev, "Can not get phy\n");
 		return 1;
 	}
 
+	napi_enable(&priv->napi_rx);
+	napi_enable(&priv->napi_tx);
 	netif_carrier_off(ndev);
 	ndev->phydev = phydev;
 	priv->phydev = phydev;
 	phy_start(ndev->phydev);
 
+	//en rx/tx for all mode
+	__raw_writel(0x20, &priv->sl1_regs->mac_control);
 	return 0;
 }
 
@@ -265,11 +307,26 @@ static int cpsw_ndo_start_xmit (struct sk_buff *skb,
                            struct net_device *ndev)
 {
 	struct newam335x_eth_priv *priv;
+	int ret;
 	priv = netdev_priv(ndev);
 
+	if (skb_padto(skb, CPSW_MIN_PACKET_SIZE)) {
+		dev_err(priv->dev, "packet pad failed\n");
+		ndev->stats.tx_dropped++;
+		return NETDEV_TX_OK;
+	}
+
+	if (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP)
+		skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
+
 	skb_tx_timestamp(skb);
-	printk("zz %s %d \n", __func__, __LINE__);
-	cpdma_submit(priv, skb, 1);
+	ret = cpdma_submit(priv, &priv->tx_chan, skb, 0);
+
+	if(ret) {
+		dev_err(priv->dev, "submit skb error\n");
+		return NETDEV_TX_BUSY;
+	}
+
     return NETDEV_TX_OK;
 }
 
@@ -301,7 +358,7 @@ static int cpsw_ndo_vlan_rx_add_vid(struct net_device *ndev,
                                __be16 proto, u16 vid)
 {
 	printk("zz %s %d \n", __func__, __LINE__);
-      return 0;
+    return 0;
 }
   
 static int cpsw_ndo_vlan_rx_kill_vid(struct net_device *ndev,
@@ -340,7 +397,7 @@ int queue_rx_packages(struct newam335x_eth_priv *priv)
 		}
 
 		skb->len = CPSW_MAX_PACKET_SIZE;
-		ret = cpdma_submit(priv, skb, 0);
+		ret = cpdma_submit(priv, &priv->rx_chan, skb, 0);
 
 		if (ret) {
 			dev_kfree_skb_any(skb);
@@ -355,69 +412,45 @@ int queue_rx_packages(struct newam335x_eth_priv *priv)
 static int eth_rx_poll(struct napi_struct *napi_rx, int budget)
 {
 	struct newam335x_eth_priv *priv;
-	//printk("zz %s %d \n", __func__, __LINE__);
+	int cnt;
 	priv = netdev_priv(napi_rx->dev);
-	handle_rx_package(priv);
-	enable_irq(priv->rx_irq);
-	//printk("zz %s %d \n", __func__, __LINE__);
-	return 0;
+
+	cnt = cpdma_handle_chan(priv, &priv->rx_chan);
+	if (cnt<budget) {
+		//printk("zz %s %d rx napi complete\n", __func__, __LINE__);
+		napi_complete(napi_rx);
+		writel(0x01, &priv->wr_regs->rx_en);
+		//enable_irq(priv->rx_irq);
+		return cnt;
+	}
+
+	return cnt;
 }
 
 static int eth_tx_poll(struct napi_struct *napi_tx, int budget)
 {
+	struct newam335x_eth_priv *priv;
+	int cnt;
+	priv = netdev_priv(napi_tx->dev);
+
+	cnt = cpdma_handle_chan(priv, &priv->tx_chan);
+	if (cnt<budget) {
+		napi_complete(napi_tx);
+		writel(0xff, &priv->wr_regs->tx_en);
+		return cnt;
+	}
 	return 0;
 }
 
-static int handle_tx_package(struct newam335x_eth_priv *priv)
+static int handle_tx_package(struct newam335x_eth_priv *priv, struct sk_buff *skb, int len)
 {
-	struct cpdma_chan *chan;
-	struct cpdma_desc *desc;
-	struct transfer_data *desc_data;
-	struct sk_buff *skb;
-	struct net_device *ndev;
-	u32 len, status;
+	struct net_device *ndev = priv->ndev;
+
+	//dump_skb(skb, len);
+	ndev->stats.tx_packets++;
+	ndev->stats.tx_bytes += len;
+	dev_kfree_skb_any(skb);
 
-	ndev = priv->ndev;
-	chan = &priv->tx_chan;
-	desc_data = list_first_entry(&chan->list, struct transfer_data, head);
-
-	if (!desc_data || !desc_data->desc)
-		return -ENOMEM;
-
-	do {
-		desc = desc_data->desc;
-		status = desc_read(desc, hw_mode);
-		if (status & CPDMA_DESC_OWNER) {
-			return -ENXIO;
-		} else {
-			desc_data = (struct transfer_data*)desc->sw_buffer;
-			skb = (struct sk_buff *) desc_data->skb;
-			len = status & 0x7ff;
-
-			ndev->stats.tx_packets++;
-			ndev->stats.tx_bytes += len;
-			dev_kfree_skb_any(skb);
-			desc_data->skb = NULL;
-			list_del(&desc_data->head);
-
-			/*last desc*/
-			if (status & CPDMA_DESC_EOQ) {
-				//printk("zz %s desc_data->head->prev:%08x desc_data->head->next:%08x \n",__func__, (int)desc_data->head.prev, (int)desc_data->head.next);
-				cpdma_free(priv, desc_data);
-				chan_write(chan, cp, DESC_PHYADDR(priv, desc_data->desc));
-				cpdma_eoi_write(priv, 2);
-
-				if (!list_empty(&chan->list)) {
-					dev_dbg(&priv->pdev->dev, "zz %s %d isn't empty\n", __func__, __LINE__);
-					desc_data = list_first_entry(&chan->list, struct transfer_data, head);
-					chan_write(chan, hdp, DESC_PHYADDR(priv, desc_data->desc));
-				}
-				return 0;
-			}
-			cpdma_free(priv, desc_data);
-		}
-		desc_data = list_first_entry(&desc_data->head, struct transfer_data, head);
-	} while(desc_data);
 	return 0;
 }
 
@@ -425,86 +458,115 @@ static irqreturn_t tx_intr(int __always_unused irq, void *data)
 {
 	struct newam335x_eth_priv *priv= data;
 
-	printk("zz %s %d +\n", __func__, __LINE__);
-	handle_tx_package(priv);
-	printk("zz %s %d -\n", __func__, __LINE__);
+	//dump_mem(priv->ss_regs, 0x2000);
+	//while(1);
+	cpdma_eoi_write(priv, priv->tx_chan.eio_val);
+	writel(0, &priv->wr_regs->tx_en);
+	napi_schedule(&priv->napi_tx);
 	return IRQ_HANDLED;
 }
 
-static int handle_rx_package(struct newam335x_eth_priv *priv)
+static int handle_rx_package(struct newam335x_eth_priv *priv, struct sk_buff *skb, int len)
 {
-	struct cpdma_chan *chan;
-	struct cpdma_desc *desc;
-	struct transfer_data *desc_data;
-	struct sk_buff *skb;
 	struct net_device *ndev;
-	u32 len, status;
+	struct sk_buff		*new_skb;
+	int			ret = 0;
 
 	ndev = priv->ndev;
-	chan = &priv->rx_chan;
-
-	while (!list_empty(&chan->list)) {
-
-		desc_data = list_first_entry(&chan->list, struct transfer_data, head);
-		desc = desc_data->desc;
 
-		status = desc_read(desc, hw_mode);
-		if (status & CPDMA_DESC_OWNER) {
-			return -ENXIO;
-		} else {
-			skb = (struct sk_buff *) desc_data->skb;
-			len = status & 0x7ff;
-
-			dump_skb(skb);
-
-			skb_put(skb, len);
-			skb->protocol = eth_type_trans(skb, ndev);
-			netif_receive_skb(skb);
-			ndev->stats.rx_bytes += len;
-			ndev->stats.rx_packets++;
-
-			chan_write(chan, cp, DESC_PHYADDR(priv, desc_data->desc));
-			cpdma_eoi_write(priv, 1);
-
-			list_del(&desc_data->head);
-			cpdma_free(priv, desc_data);
-
-			/*last desc*/
-			if (status & CPDMA_DESC_EOQ) {
-
-				if (!list_empty(&chan->list)) {
-					dev_dbg(&priv->pdev->dev, "list isn't empty, continue write\n");
-					desc_data = list_first_entry(&chan->list, struct transfer_data, head);
-					chan_write(chan, hdp, DESC_PHYADDR(priv, desc_data->desc));
-				} else {
-					queue_rx_packages(priv);
-				}
-
-				return 0;
-			}
-		}
-	};
+	//dump_skb(skb, len);
+			
+	new_skb = netdev_alloc_skb_ip_align(ndev, CPSW_MAX_PACKET_SIZE);
+	if (new_skb) {
+		skb_put(skb, len);
+		skb->protocol = eth_type_trans(skb, ndev);
+		//printk("zz %s skb->protocol:%08x len:%08x \n",__func__, (int)skb->protocol, (int)len);
+		netif_receive_skb(skb);
+		ndev->stats.rx_bytes += len;
+		ndev->stats.rx_packets++;
+	} else {
+		ndev->stats.rx_dropped++;
+		new_skb = skb;
+	}
 
+	new_skb->len = CPSW_MAX_PACKET_SIZE;
+	ret = cpdma_submit(priv, &priv->rx_chan, new_skb, 0);
+	if (ret) {
+		dev_err(priv->dev, "submit error\n");
+	}
 	return 0;
 }
 
 static irqreturn_t rx_intr(int __always_unused irq, void *data)
 {
 	struct newam335x_eth_priv *priv= data;
-	//__napi_schedule(&priv->napi_rx); it is halt in irq context
-	//__napi_schedule_irqoff(&priv->napi_rx);
-	//disable_irq_nosync(irq);
-	handle_rx_package(priv);
+
+	cpdma_eoi_write(priv, priv->rx_chan.eio_val);
+	writel(0, &priv->wr_regs->rx_en);
+	napi_schedule(&priv->napi_rx);
+
 	return IRQ_HANDLED;
 }
 
+#define CPSW_MDIO_BASE  	(0x4A101000)
+static struct resource newam335x_mdio_resources[] = {
+	{
+		.start	= CPSW_MDIO_BASE,
+		.end	= CPSW_MDIO_BASE + 0x100,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+void phy_node_init(struct newam335x_eth_priv *priv)
+{
+	struct device_node *node = priv->pdev->dev.of_node;
+	struct device_node *slave_node;
+	int i;
+
+	for_each_child_of_node(node, slave_node) {
+		u32 phyid;
+		int lenp;
+		const __be32 *parp;
+		struct device_node *mdio_node;
+		struct platform_device *mdio;
+
+		/* This is no slave child node, continue */
+		if (strcmp(slave_node->name, "slave"))
+			continue;
+
+		printk("zz %s %d \n", __func__, __LINE__);
+		parp = of_get_property(slave_node, "phy_id", &lenp);
+		if ((parp == NULL) || (lenp != (sizeof(void *) * 2))) {
+			dev_err(&priv->pdev->dev, "Missing slave[%d] phy_id property\n", i);
+		}
+		printk("zz %s %d \n", __func__, __LINE__);
+		mdio_node = of_find_node_by_phandle(be32_to_cpup(parp));
+		phyid = be32_to_cpup(parp+1);
+		mdio = of_find_device_by_node(mdio_node);
+		of_node_put(mdio_node);
+		if (!mdio) {
+			dev_err(&priv->pdev->dev, "Missing mdio platform device\n");
+			return ;
+		}
+		snprintf(priv->phy_id, sizeof(priv->phy_id),
+			 PHY_ID_FMT, mdio->name, phyid);
+
+		priv->phy_if = of_get_phy_mode(slave_node);
+		break;
+	}
+}
+
 static int newam335x_eth_probe(struct platform_device *pdev)
 {
 	struct resource *res;
 	struct newam335x_eth_priv *priv;
 	struct net_device *ndev;
-	int i, ret, irq, k=0;
+	int i, ret=0, irq, k=0;
 	void __iomem *base;
+	struct device_node *node = pdev->dev.of_node;
+
+	printk("zz %s %d \n", __func__, __LINE__);
+
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
 		dev_err(&pdev->dev, "resource not find");
@@ -526,7 +588,7 @@ static int newam335x_eth_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
-	printk("zz %s base:%08x \n",__func__, base);
+	printk("zz %s base:%08x \n",__func__, (int)base);
 
 	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 	if (!res) {
@@ -562,6 +624,7 @@ static int newam335x_eth_probe(struct platform_device *pdev)
 #define CPSW_CPDMA_OFFSET 		0x800
 #define CPSW_WR_OFFSET 			0x1200
 	priv->pdev = pdev;
+	priv->dev = &pdev->dev;
 	priv->ss_regs = base;
 	priv->sl1_regs = (struct cpsw_sl_regs *) (base+CPSW_SL1_OFFSET);
 	priv->sl2_regs = (struct cpsw_sl_regs *) (base+CPSW_SL2_OFFSET);
@@ -572,20 +635,7 @@ static int newam335x_eth_probe(struct platform_device *pdev)
 	priv->ale_regs = (void*) base+CPSW_ALE_OFFSET;
 	priv->dma_regs = (void*) base+CPSW_CPDMA_OFFSET;
 
-	INIT_LIST_HEAD(&priv->free_list);
-	priv->desc		= (struct cpdma_desc*) (base+CPPI_RAM_OFFSET);
-	priv->desc_free = &priv->desc[0];
-
-	for (i = 0; i < PACKAGE_NUM; ++i) {
-		priv->package_list[i].desc= &priv->desc[i];
-		INIT_LIST_HEAD(&priv->package_list[i].head);
-		{
-			struct transfer_data *desc_data;
-			desc_data= &priv->package_list[i];
-			printk("zz %s desc_data->head->prev:%08x desc_data->head->next:%08x \n",__func__, (int)desc_data->head.prev, (int)desc_data->head.next);
-		}
-		list_add_tail(&priv->package_list[i].head, &priv->free_list);
-	}
+	priv->dma_ram = base+CPPI_RAM_OFFSET;
 
 	ndev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;
 	ndev->netdev_ops = &newam335x_netdev_ops;
@@ -604,7 +654,7 @@ static int newam335x_eth_probe(struct platform_device *pdev)
 	priv->defaut_mac[5] = 0xfb;
 #endif
 	netif_napi_add(ndev, &priv->napi_rx, eth_rx_poll, POLL_WEIGHT);
-	netif_tx_napi_add(ndev, &priv->napi_tx, eth_tx_poll, POLL_WEIGHT);
+	netif_napi_add(ndev, &priv->napi_tx, eth_tx_poll, POLL_WEIGHT);
 
 	ether_addr_copy(ndev->dev_addr, priv->defaut_mac);
 	printk("mac: %02x:%02x:%02x:%02x:%02x:%02x \n",
@@ -617,6 +667,7 @@ static int newam335x_eth_probe(struct platform_device *pdev)
 	/* register the network device */
 	SET_NETDEV_DEV(ndev, &pdev->dev);
 
+
 	ret = register_netdev(ndev);
 	if (ret) {
 		dev_err(&pdev->dev, "error registering net device\n");
@@ -638,15 +689,23 @@ static int newam335x_eth_remove(struct platform_device *pdev)
   return 0;
 }
 
+static const struct of_device_id cpsw_of_mtable[] = {
+	{ .compatible = "ti,cpsw", },
+	{ .compatible = "ti,am335x-cpsw", },
+	{ .compatible = "ti,am4372-cpsw", },
+	{ .compatible = "ti,dra7-cpsw", },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, cpsw_of_mtable);
 static struct platform_driver newam335x_eth_driver = {
-  .driver = {
-	  .name    = "newam335x_eth_cpsw",
-	  .owner   = THIS_MODULE,
-	  //.pm    = &cpsw_pm_ops,
-	  //.of_match_table = cpsw_of_mtable,
-  },
-  .probe = newam335x_eth_probe,
-  .remove = newam335x_eth_remove,
+	.driver = {
+		.name    = "newam335x_eth_cpsw",
+		.owner   = THIS_MODULE,
+		//.pm    = &cpsw_pm_ops,
+		.of_match_table = cpsw_of_mtable,
+	},
+	.probe = newam335x_eth_probe,
+	.remove = newam335x_eth_remove,
 };
 
 module_platform_driver(newam335x_eth_driver);
diff --git a/drivers/net/ethernet/newam335x/newam335x_eth_cpsw.h b/drivers/net/ethernet/newam335x/newam335x_eth_cpsw.h
index 97f6474..70f845d 100644
--- a/drivers/net/ethernet/newam335x/newam335x_eth_cpsw.h
+++ b/drivers/net/ethernet/newam335x/newam335x_eth_cpsw.h
@@ -1,19 +1,30 @@
 #ifndef __NEWAM335X_ETH_CPSW_H__
+
 #define __NEWAM335X_ETH_CPSW_H__
 #include <linux/inetdevice.h>
 
+struct newam335x_eth_priv;
+
 struct cpsw_ss_regs {
 	u32	id_ver;
 	u32	control;
 	u32	soft_reset;
 	u32	stat_port_en;
 	u32	ptype;
+	u32	soft_idle;
+	u32	thru_rate;
+	u32	gap_thresh;
+	u32	tx_start_wds;
+	u32	flow_control;
+	u32	vlan_ltype;
+	u32	ts_ltype;
+	u32	dlr_ltype;
 };
 
 struct cpsw_port1_regs {
 	u32	max_blks;
 	u32	blk_cnt;
-	u32	flow_thresh;
+	u32	ftx_in_ctl;
 	u32	port_vlan;
 	u32	tx_pri_map;
 	u32	gap_thresh;
@@ -24,7 +35,7 @@ struct cpsw_port1_regs {
 struct cpsw_port0_regs {
 	u32	max_blks;
 	u32	blk_cnt;
-	u32	flow_thresh;
+	u32	tx_in_ctl;
 	u32	port_vlan;
 	u32	tx_pri_map;
 	u32	cpdma_tx_pri_map;
@@ -51,14 +62,22 @@ struct cpdma_desc {
 	u32			hw_len;
 	u32			hw_mode;
 	/* software fields */
+	u32			*token;
 	u32			sw_buffer;
 	u32			sw_len;
 };
 
+typedef int (*desc_handle_callback)(struct newam335x_eth_priv *priv, struct sk_buff *skb, int len);
 struct cpdma_chan {
-	//struct cpdma_desc	*head, *tail;
-	struct list_head list;
+	desc_handle_callback handle;
+	struct cpdma_desc *head, *tail;
 	void *hdp, *cp, *rxfree;
+	int eio_val; //tx 2, rx 1
+	int start_number;
+	int end_number;
+	int min_len;
+	enum dma_data_direction	dir;
+	spinlock_t lock;
 };
 
 struct cpsw_wr_regs {
@@ -119,20 +138,24 @@ struct cpsw_hw_stats {
 	u32	rxdmaoverruns;
 };
 
-struct transfer_data {
-	void *skb;
-	struct cpdma_desc * desc;
-	struct list_head head;
+struct cpdma_desc_pool {
+	dma_addr_t pool_phy;
+	void __iomem *pool_vir;
+	ulong *bitmap;
+	int number;
+	spinlock_t lock;
 };
 
-#define PACKAGE_NUM (16)
-#define RX_PACKAGE_NUM (8)
+#define RX_PACKAGE_NUM (64)
+//#define RX_PACKAGE_NUM (1)
 struct newam335x_eth_priv {
 	struct platform_device *pdev;
+	struct device *dev;
 	struct net_device	*ndev;
 	struct phy_device *phydev;
 	int phyaddr;
 	int phytype;
+	int mac_control;
 	struct napi_struct napi_tx;
 	struct napi_struct napi_rx;
 	struct cpsw_ss_regs *ss_regs;
@@ -145,16 +168,18 @@ struct newam335x_eth_priv {
 	struct newam335x_mdio_regs *mdio_regs;
 	void *ale_regs;
 	void *dma_regs;
-	struct cpdma_desc *desc;
-	struct cpdma_desc		*desc_free;
-	struct cpdma_chan		rx_chan, tx_chan;
+	struct cpdma_chan	rx_chan, tx_chan;
 	int rx_irq;
 	int tx_irq;
 	u8 defaut_mac[6];
-	struct transfer_data  package_list[PACKAGE_NUM];
-	struct list_head free_list;
+	struct clk *fck_clk;
+	char phy_id[64];
+	phy_interface_t phy_if;
+	struct cpdma_desc_pool *pool;
+	void __iomem *dma_ram;
 };
 
+#define CPSW_SS_BASE  	(0x4a100000)
 #define CPPI_RAM_BASE 	(0x4A102000)
 #define CPPI_RAM_OFFSET (0x2000)
 #define CPSW_MDIO_OFFSET (0x1000)
@@ -187,6 +212,8 @@ struct newam335x_eth_priv {
 #define CPSW_ALE_PORTCTL4  0x50
 /*ADDRESS LOOKUP ENGINE PORT 5 CONTROL*/
 #define CPSW_ALE_PORTCTL5  0x54
+#define CPSW_ALE_VLAN_AWARE	1
+#define CPSW_VLAN_AWARE		(1<<1)
 
 
 
-- 
1.9.1

